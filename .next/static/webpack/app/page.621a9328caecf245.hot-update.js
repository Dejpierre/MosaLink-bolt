"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/BentoGrid.tsx":
/*!**************************************!*\
  !*** ./src/components/BentoGrid.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BentoGrid: function() { return /* binding */ BentoGrid; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/dom/motion.mjs\");\n/* harmony import */ var _store_useStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/useStore */ \"(app-pages-browser)/./src/store/useStore.ts\");\n/* harmony import */ var _BentoCardComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BentoCardComponent */ \"(app-pages-browser)/./src/components/BentoCardComponent.tsx\");\n/* harmony import */ var _barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Crown,Plus!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/plus.js\");\n/* harmony import */ var _barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Crown,Plus!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/crown.js\");\n/* harmony import */ var react_grid_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-grid-layout */ \"(app-pages-browser)/./node_modules/react-grid-layout/index.js\");\n/* harmony import */ var react_grid_layout__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_grid_layout__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_grid_layout_css_styles_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-grid-layout/css/styles.css */ \"(app-pages-browser)/./node_modules/react-grid-layout/css/styles.css\");\n/* harmony import */ var _ResizableCard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ResizableCard */ \"(app-pages-browser)/./src/components/ResizableCard.tsx\");\n/* __next_internal_client_entry_do_not_use__ BentoGrid,default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst BentoGrid = (param)=>{\n    let { cards, isPreview = false, onCardClick, className = \"\" } = param;\n    _s();\n    const { currentLayout, updateCard, addCard, userPlan } = (0,_store_useStore__WEBPACK_IMPORTED_MODULE_2__.useStore)();\n    const [gridDimensions, setGridDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [cellSize, setCellSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(100);\n    const [hoveredCell, setHoveredCell] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const gridRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLayoutChanging, setIsLayoutChanging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [addingCard, setAddingCard] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [emptyGridCells, setEmptyGridCells] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Calculate grid dimensions on mount and resize\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setMounted(true);\n        const calculateDimensions = ()=>{\n            if (gridRef.current) {\n                const rect = gridRef.current.getBoundingClientRect();\n                setGridDimensions({\n                    width: rect.width,\n                    height: rect.height\n                });\n                // Calculate cell size based on grid width and columns\n                const cols = getGridColumns();\n                const gapSize = getGap();\n                const totalGapWidth = gapSize * (cols - 1);\n                const availableWidth = rect.width - totalGapWidth;\n                const calculatedCellSize = Math.floor(availableWidth / cols);\n                setCellSize(calculatedCellSize);\n            }\n        };\n        calculateDimensions();\n        const resizeObserver = new ResizeObserver(calculateDimensions);\n        if (gridRef.current) {\n            resizeObserver.observe(gridRef.current);\n        }\n        window.addEventListener(\"resize\", calculateDimensions);\n        return ()=>{\n            resizeObserver.disconnect();\n            window.removeEventListener(\"resize\", calculateDimensions);\n        };\n    }, [\n        currentLayout\n    ]);\n    // Effect to fix card positions when layout changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mounted) return;\n        // VÃ©rifier si des cartes ont des positions invalides pour le layout actuel\n        const maxCols = getGridColumns();\n        const cardsToFix = cards.filter((card)=>{\n            if (!card.gridPosition) return false;\n            const { colSpan } = getCardSize(card);\n            return card.gridPosition.col + colSpan > maxCols;\n        });\n        // Corriger les positions invalides\n        cardsToFix.forEach((card)=>{\n            if (card.gridPosition) {\n                const { colSpan } = getCardSize(card);\n                const newCol = Math.max(0, Math.min(card.gridPosition.col, maxCols - colSpan));\n                console.log(\"Fixing card \".concat(card.id, \": col \").concat(card.gridPosition.col, \" -> \").concat(newCol, \", colSpan: \").concat(colSpan, \", maxCols: \").concat(maxCols));\n                updateCard(card.id, {\n                    gridPosition: {\n                        ...card.gridPosition,\n                        col: newCol\n                    }\n                });\n            }\n        });\n    }, [\n        currentLayout,\n        mounted,\n        cards\n    ]);\n    // Determine number of columns based on layout\n    const getGridColumns = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 2;\n            case \"tablet\":\n                return 4;\n            case \"desktop\":\n            default:\n                return 12;\n        }\n    };\n    // Determine number of rows based on layout - FIXED TO 6 ROWS MAX\n    const getGridRows = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 6;\n            case \"tablet\":\n                return 6;\n            case \"desktop\":\n            default:\n                return 6;\n        }\n    };\n    // Determine gap based on layout\n    const getGap = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 8;\n            case \"tablet\":\n                return 12;\n            case \"desktop\":\n            default:\n                return 16;\n        }\n    };\n    // Convert card size to column and row span - FIXED LOGIC\n    const getCardSize = (card)=>{\n        const [colSpan, rowSpan] = card.size.split(\"x\").map(Number);\n        // Debug: Log la taille de la carte\n        console.log(\"Card \".concat(card.id, \" size: \").concat(card.size, \" -> colSpan: \").concat(colSpan, \", rowSpan: \").concat(rowSpan, \", layout: \").concat(currentLayout));\n        // Adapt size based on layout\n        if (currentLayout === \"mobile\") {\n            // On mobile, limit to 2 columns max\n            const adaptedColSpan = Math.min(colSpan, 2);\n            return {\n                colSpan: adaptedColSpan,\n                rowSpan\n            };\n        } else if (currentLayout === \"tablet\") {\n            // On tablet, limit to 4 columns max\n            const adaptedColSpan = Math.min(colSpan, 4);\n            return {\n                colSpan: adaptedColSpan,\n                rowSpan\n            };\n        } else {\n            // On desktop, use the actual size from card.size\n            return {\n                colSpan: Math.min(colSpan, 12),\n                rowSpan: Math.min(rowSpan, 6)\n            };\n        }\n    };\n    // Check for collisions\n    const hasCollision = (cardId, col1, row1, colSpan, rowSpan)=>{\n        // Check grid boundaries\n        if (col1 < 0 || row1 < 0 || col1 + colSpan > getGridColumns() || row1 + rowSpan > getGridRows()) {\n            return true;\n        }\n        for (const card of cards){\n            if (card.id === cardId || !card.gridPosition) continue;\n            const { colSpan: cardColSpan, rowSpan: cardRowSpan } = getCardSize(card);\n            // Check if rectangles overlap\n            const overlap = !(col1 >= card.gridPosition.col + cardColSpan || // Right\n            col1 + colSpan <= card.gridPosition.col || // Left\n            row1 >= card.gridPosition.row + cardRowSpan || // Bottom\n            row1 + rowSpan <= card.gridPosition.row // Top\n            );\n            if (overlap) return true;\n        }\n        return false;\n    };\n    // Intelligent resize function\n    const handleIntelligentResize = (cardId, newCols, newRows)=>{\n        const card = cards.find((c)=>c.id === cardId);\n        if (!card || !card.gridPosition) return false;\n        const currentCol = card.gridPosition.col;\n        const currentRow = card.gridPosition.row;\n        // Check grid limits\n        if (currentCol + newCols > getGridColumns() || currentRow + newRows > getGridRows()) {\n            return false;\n        }\n        // Check for collisions\n        if (hasCollision(cardId, currentCol, currentRow, newCols, newRows)) {\n            return false;\n        }\n        return true;\n    };\n    // Convert cards to React-Grid-Layout format\n    const getLayoutItems = ()=>{\n        return cards.map((card)=>{\n            if (!card.gridPosition) return null;\n            const { colSpan, rowSpan } = getCardSize(card);\n            // DEBUG: Log card layout info\n            console.log(\"Card \".concat(card.id, \" layout:\"), {\n                size: card.size,\n                colSpan,\n                rowSpan,\n                position: card.gridPosition,\n                currentLayout,\n                gridColumns: getGridColumns()\n            });\n            return {\n                i: card.id,\n                x: card.gridPosition.col,\n                y: card.gridPosition.row,\n                w: colSpan,\n                h: rowSpan,\n                static: isPreview,\n                maxW: getGridColumns(),\n                maxH: getGridRows()\n            };\n        }).filter(Boolean);\n    };\n    // Handle layout change from React-Grid-Layout\n    const handleLayoutChange = (layout)=>{\n        if (isPreview || isLayoutChanging) return;\n        // Set a flag to prevent multiple updates\n        setIsLayoutChanging(true);\n        // Process layout changes one by one to prevent cascading updates\n        const updates = layout.map((item)=>{\n            const card = cards.find((c)=>c.id === item.i);\n            if (card && card.gridPosition) {\n                if (card.gridPosition.col !== item.x || card.gridPosition.row !== item.y) {\n                    return {\n                        id: card.id,\n                        x: item.x,\n                        y: item.y\n                    };\n                }\n            }\n            return null;\n        }).filter(Boolean);\n        // Apply updates sequentially\n        if (updates.length > 0) {\n            // Only update the card that was actually moved by the user\n            const update = updates[0];\n            if (update) {\n                updateCard(update.id, {\n                    gridPosition: {\n                        col: update.x,\n                        row: update.y\n                    }\n                });\n            }\n        }\n        // Reset the flag after a short delay\n        setTimeout(()=>{\n            setIsLayoutChanging(false);\n        }, 100);\n    };\n    // Check if a cell is free (not occupied by any card)\n    const isCellFree = (row1, col1)=>{\n        if (row1 >= getGridRows() || col1 >= getGridColumns()) return false;\n        // Check if any card occupies this cell\n        for (const card of cards){\n            if (!card.gridPosition) continue;\n            const { colSpan, rowSpan } = getCardSize(card);\n            const cardStartCol = card.gridPosition.col;\n            const cardEndCol = cardStartCol + colSpan - 1;\n            const cardStartRow = card.gridPosition.row;\n            const cardEndRow = cardStartRow + rowSpan - 1;\n            if (col1 >= cardStartCol && col1 <= cardEndCol && row1 >= cardStartRow && row1 <= cardEndRow) {\n                return false;\n            }\n        }\n        return true;\n    };\n    // Function to add a new card at a specific position - CORRECTED\n    const handleAddCard = async (type, position)=>{\n        // Check if the cell is free\n        if (!isCellFree(row, col) || addingCard) return;\n        setAddingCard(true);\n        try {\n            // Taille adaptÃ©e au layout actuel\n            let cardSize;\n            switch(currentLayout){\n                case \"mobile\":\n                    cardSize = \"1x1\";\n                    break;\n                case \"tablet\":\n                    cardSize = \"2x2\";\n                    break;\n                case \"desktop\":\n                default:\n                    cardSize = \"2x2\"; // Taille fixe pour desktop\n                    break;\n            }\n            console.log(\"Adding card with size: \".concat(cardSize, \" at position (\").concat(col, \", \").concat(row, \") for layout: \").concat(currentLayout));\n            const newCard = {\n                type,\n                title: \"\",\n                description: \"\",\n                url: \"\",\n                backgroundColor: \"#6366f1\",\n                textColor: \"#ffffff\",\n                size: cardSize,\n                gridPosition: finalPosition\n            };\n            const result = await addCard(newCard);\n            if (!result.success) {\n                alert(result.error);\n            } else {\n                // Open editor for the new card\n                onCardClick && onCardClick(result.cardId || \"\");\n            }\n        } catch (error) {\n            console.error(\"Error adding card:\", error);\n        } finally{\n            setAddingCard(false);\n        }\n    };\n    // Check plan limits\n    const canAddMoreCards = ()=>{\n        if (userPlan === \"free\") return cards.length < 3;\n        if (userPlan === \"starter\") return cards.length < 25;\n        return true; // Pro plan = unlimited\n    };\n    // Calculate grid height based on content\n    const gridHeight = getGridRows() * cellSize + (getGridRows() - 1) * getGap();\n    // Calculate all empty cells for the grid - FIXED\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const maxCols = getGridColumns();\n        const maxRows = getGridRows();\n        const emptyCells = [];\n        // Check each cell in the grid\n        for(let row1 = 0; row1 < maxRows; row1++){\n            for(let col1 = 0; col1 < maxCols; col1++){\n                if (isCellFree(row1, col1)) {\n                    // Logique adaptÃ©e au layout\n                    if (currentLayout === \"desktop\") {\n                        // Pour desktop, vÃ©rifier l'espace pour une carte 2x2\n                        let hasSpace = true;\n                        // VÃ©rifier si on a assez d'espace (2x2)\n                        if (col1 + 2 > maxCols || row1 + 2 > maxRows) {\n                            hasSpace = false;\n                        } else {\n                            // VÃ©rifier que toutes les cellules nÃ©cessaires sont libres\n                            for(let r = row1; r < row1 + 2; r++){\n                                for(let c = col1; c < col1 + 2; c++){\n                                    if (!isCellFree(r, c)) {\n                                        hasSpace = false;\n                                        break;\n                                    }\n                                }\n                                if (!hasSpace) break;\n                            }\n                        }\n                        if (hasSpace) {\n                            emptyCells.push({\n                                row: row1,\n                                col: col1\n                            });\n                        }\n                    } else if (currentLayout === \"tablet\") {\n                        // Pour tablet, vÃ©rifier l'espace pour une carte 2x2\n                        let hasSpace = true;\n                        if (col1 + 2 > maxCols || row1 + 2 > maxRows) {\n                            hasSpace = false;\n                        } else {\n                            for(let r = row1; r < row1 + 2; r++){\n                                for(let c = col1; c < col1 + 2; c++){\n                                    if (!isCellFree(r, c)) {\n                                        hasSpace = false;\n                                        break;\n                                    }\n                                }\n                                if (!hasSpace) break;\n                            }\n                        }\n                        if (hasSpace) {\n                            emptyCells.push({\n                                row: row1,\n                                col: col1\n                            });\n                        }\n                    } else {\n                        // Pour mobile, ajouter directement (1x1)\n                        emptyCells.push({\n                            row: row1,\n                            col: col1\n                        });\n                    }\n                }\n            }\n        }\n        setEmptyGridCells(emptyCells);\n    }, [\n        cards,\n        currentLayout,\n        mounted\n    ]);\n    // Use fallback values to ensure GridLayout always receives valid props\n    const safeGridWidth = gridDimensions.width || 1200;\n    const safeCellSize = cellSize || 100;\n    if (!mounted) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full h-96 bg-gray-100 rounded-lg animate-pulse flex items-center justify-center\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-gray-400\",\n                children: \"Loading grid...\"\n            }, void 0, false, {\n                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                lineNumber: 418,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n            lineNumber: 417,\n            columnNumber: 7\n        }, undefined);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: gridRef,\n        className: \"relative touch-none w-full \".concat(className),\n        style: {\n            height: gridHeight,\n            minHeight: \"300px\",\n            position: \"relative\",\n            width: \"100%\"\n        },\n        children: isPreview ? // Preview mode - static grid\n        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                display: \"grid\",\n                gridTemplateColumns: \"repeat(\".concat(getGridColumns(), \", 1fr)\"),\n                gridTemplateRows: \"repeat(\".concat(getGridRows(), \", 1fr)\"),\n                gap: \"\".concat(getGap(), \"px\"),\n                height: \"100%\",\n                width: \"100%\"\n            },\n            children: cards.map((card)=>{\n                if (!card.gridPosition) return null;\n                // Get grid span\n                const { colSpan, rowSpan } = getCardSize(card);\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        gridColumn: \"\".concat(card.gridPosition.col + 1, \" / span \").concat(colSpan),\n                        gridRow: \"\".concat(card.gridPosition.row + 1, \" / span \").concat(rowSpan),\n                        position: \"relative\"\n                    },\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_BentoCardComponent__WEBPACK_IMPORTED_MODULE_3__.BentoCardComponent, {\n                        card: card,\n                        isPreviewMode: true\n                    }, void 0, false, {\n                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                        lineNumber: 461,\n                        columnNumber: 17\n                    }, undefined)\n                }, card.id, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 453,\n                    columnNumber: 15\n                }, undefined);\n            })\n        }, void 0, false, {\n            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n            lineNumber: 436,\n            columnNumber: 9\n        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_grid_layout__WEBPACK_IMPORTED_MODULE_4___default()), {\n                    className: \"layout\",\n                    layout: getLayoutItems(),\n                    cols: getGridColumns(),\n                    rowHeight: safeCellSize,\n                    width: safeGridWidth,\n                    margin: [\n                        getGap(),\n                        getGap()\n                    ],\n                    containerPadding: [\n                        0,\n                        0\n                    ],\n                    onLayoutChange: handleLayoutChange,\n                    isDraggable: !isPreview && currentLayout === \"desktop\",\n                    isResizable: false,\n                    compactType: null,\n                    preventCollision: true,\n                    useCSSTransforms: true,\n                    draggableHandle: \".drag-handle\",\n                    maxRows: getGridRows(),\n                    resizeHandles: [],\n                    autoSize: false,\n                    children: cards.map((card)=>{\n                        if (!card.gridPosition) return null;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"h-full w-full\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ResizableCard__WEBPACK_IMPORTED_MODULE_6__.ResizableCard, {\n                                card: card,\n                                cellSize: safeCellSize,\n                                gap: getGap(),\n                                maxCols: getGridColumns(),\n                                maxRows: getGridRows(),\n                                onIntelligentResize: handleIntelligentResize,\n                                onEdit: ()=>onCardClick && onCardClick(card.id)\n                            }, void 0, false, {\n                                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                lineNumber: 495,\n                                columnNumber: 19\n                            }, undefined)\n                        }, card.id, false, {\n                            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                            lineNumber: 494,\n                            columnNumber: 17\n                        }, undefined);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 471,\n                    columnNumber: 11\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute inset-0 pointer-events-none\",\n                    style: {\n                        display: \"grid\",\n                        gridTemplateColumns: \"repeat(\".concat(getGridColumns(), \", 1fr)\"),\n                        gridTemplateRows: \"repeat(\".concat(getGridRows(), \", 1fr)\"),\n                        gap: \"\".concat(getGap(), \"px\"),\n                        zIndex: 5\n                    },\n                    children: emptyGridCells.map((param)=>{\n                        let { row: row1, col: col1 } = param;\n                        const isHovered = (hoveredCell === null || hoveredCell === void 0 ? void 0 : hoveredCell.row) === row1 && (hoveredCell === null || hoveredCell === void 0 ? void 0 : hoveredCell.col) === col1;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                gridColumn: col1 + 1,\n                                gridRow: row1 + 1,\n                                position: \"relative\"\n                            },\n                            className: \"cursor-pointer pointer-events-auto\",\n                            onMouseEnter: ()=>setHoveredCell({\n                                    row: row1,\n                                    col: col1\n                                }),\n                            onMouseLeave: ()=>setHoveredCell(null),\n                            onClick: ()=>handleAddCard(row1, col1),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_7__.motion.div, {\n                                initial: {\n                                    opacity: 0\n                                },\n                                animate: {\n                                    opacity: isHovered ? 1 : 0,\n                                    scale: isHovered ? 1 : 0.8\n                                },\n                                className: \"absolute inset-0 rounded-lg border-2 border-dashed border-indigo-500/40 bg-indigo-500/10 flex items-center justify-center\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_7__.motion.div, {\n                                    whileHover: {\n                                        scale: 1.1\n                                    },\n                                    whileTap: {\n                                        scale: 0.9\n                                    },\n                                    className: \"p-2 rounded-full \".concat(canAddMoreCards() ? \"bg-indigo-500 text-white\" : \"bg-red-500 text-white\"),\n                                    children: canAddMoreCards() ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                        size: 16\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                        lineNumber: 555,\n                                        columnNumber: 25\n                                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                        size: 16\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                        lineNumber: 557,\n                                        columnNumber: 25\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                    lineNumber: 545,\n                                    columnNumber: 21\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                lineNumber: 537,\n                                columnNumber: 19\n                            }, undefined)\n                        }, \"cell-\".concat(row1, \"-\").concat(col1), false, {\n                            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                            lineNumber: 524,\n                            columnNumber: 17\n                        }, undefined);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 510,\n                    columnNumber: 11\n                }, undefined)\n            ]\n        }, void 0, true)\n    }, void 0, false, {\n        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n        lineNumber: 424,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BentoGrid, \"ePZ/kSnA4GWM+vVVjawRExn3RvE=\", false, function() {\n    return [\n        _store_useStore__WEBPACK_IMPORTED_MODULE_2__.useStore\n    ];\n});\n_c = BentoGrid;\n/* harmony default export */ __webpack_exports__[\"default\"] = (BentoGrid);\nvar _c;\n$RefreshReg$(_c, \"BentoGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0JlbnRvR3JpZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTJEO0FBQ0g7QUFDWDtBQUVhO0FBQ1Q7QUFDTjtBQUNEO0FBQ007QUFTekMsTUFBTVcsWUFBc0M7UUFBQyxFQUNsREMsS0FBSyxFQUNMQyxZQUFZLEtBQUssRUFDakJDLFdBQVcsRUFDWEMsWUFBWSxFQUFFLEVBQ2Y7O0lBQ0MsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUUsR0FBR2QseURBQVFBO0lBQ2pFLE1BQU0sQ0FBQ2UsZ0JBQWdCQyxrQkFBa0IsR0FBR3BCLCtDQUFRQSxDQUFDO1FBQUVxQixPQUFPO1FBQUdDLFFBQVE7SUFBRTtJQUMzRSxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR3hCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ3lCLGFBQWFDLGVBQWUsR0FBRzFCLCtDQUFRQSxDQUFzQztJQUNwRixNQUFNMkIsVUFBVXpCLDZDQUFNQSxDQUFpQjtJQUN2QyxNQUFNLENBQUMwQixTQUFTQyxXQUFXLEdBQUc3QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUM4QixrQkFBa0JDLG9CQUFvQixHQUFHL0IsK0NBQVFBLENBQUM7SUFDekQsTUFBTSxDQUFDZ0MsWUFBWUMsY0FBYyxHQUFHakMsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDa0MsZ0JBQWdCQyxrQkFBa0IsR0FBR25DLCtDQUFRQSxDQUErQixFQUFFO0lBRXJGLGdEQUFnRDtJQUNoREMsZ0RBQVNBLENBQUM7UUFDUjRCLFdBQVc7UUFFWCxNQUFNTyxzQkFBc0I7WUFDMUIsSUFBSVQsUUFBUVUsT0FBTyxFQUFFO2dCQUNuQixNQUFNQyxPQUFPWCxRQUFRVSxPQUFPLENBQUNFLHFCQUFxQjtnQkFDbERuQixrQkFBa0I7b0JBQUVDLE9BQU9pQixLQUFLakIsS0FBSztvQkFBRUMsUUFB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TTtBQXVpQmIsK0RBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQmVudG9HcmlkLnRzeD80YzhmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnZnJhbWVyLW1vdGlvbic7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJy4uL3N0b3JlL3VzZVN0b3JlJztcbmltcG9ydCB7IEJlbnRvQ2FyZCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEJlbnRvQ2FyZENvbXBvbmVudCB9IGZyb20gJy4vQmVudG9DYXJkQ29tcG9uZW50JztcbmltcG9ydCB7IFBsdXMsIENyb3duLCBNb3ZlIH0gZnJvbSAnbHVjaWRlLXJlYWN0JztcbmltcG9ydCBHcmlkTGF5b3V0IGZyb20gJ3JlYWN0LWdyaWQtbGF5b3V0JztcbmltcG9ydCAncmVhY3QtZ3JpZC1sYXlvdXQvY3NzL3N0eWxlcy5jc3MnO1xuaW1wb3J0IHsgUmVzaXphYmxlQ2FyZCB9IGZyb20gJy4vUmVzaXphYmxlQ2FyZCc7XG5cbmludGVyZmFjZSBCZW50b0dyaWRQcm9wcyB7XG4gIGNhcmRzOiBCZW50b0NhcmRbXTtcbiAgaXNQcmV2aWV3PzogYm9vbGVhbjtcbiAgb25DYXJkQ2xpY2s/OiAoY2FyZElkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IEJlbnRvR3JpZDogUmVhY3QuRkM8QmVudG9HcmlkUHJvcHM+ID0gKHtcbiAgY2FyZHMsXG4gIGlzUHJldmlldyA9IGZhbHNlLFxuICBvbkNhcmRDbGljayxcbiAgY2xhc3NOYW1lID0gJydcbn0pID0+IHtcbiAgY29uc3QgeyBjdXJyZW50TGF5b3V0LCB1cGRhdGVDYXJkLCBhZGRDYXJkLCB1c2VyUGxhbiB9ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgW2dyaWREaW1lbnNpb25zLCBzZXRHcmlkRGltZW5zaW9uc10gPSB1c2VTdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gIGNvbnN0IFtjZWxsU2l6ZSwgc2V0Q2VsbFNpemVdID0gdXNlU3RhdGUoMTAwKTtcbiAgY29uc3QgW2hvdmVyZWRDZWxsLCBzZXRIb3ZlcmVkQ2VsbF0gPSB1c2VTdGF0ZTx7IHJvdzogbnVtYmVyOyBjb2w6IG51bWJlciB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGdyaWRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0xheW91dENoYW5naW5nLCBzZXRJc0xheW91dENoYW5naW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2FkZGluZ0NhcmQsIHNldEFkZGluZ0NhcmRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZW1wdHlHcmlkQ2VsbHMsIHNldEVtcHR5R3JpZENlbGxzXSA9IHVzZVN0YXRlPHtyb3c6IG51bWJlciwgY29sOiBudW1iZXJ9W10+KFtdKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBncmlkIGRpbWVuc2lvbnMgb24gbW91bnQgYW5kIHJlc2l6ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgXG4gICAgY29uc3QgY2FsY3VsYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgIGlmIChncmlkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGdyaWRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgc2V0R3JpZERpbWVuc2lvbnMoeyB3aWR0aDogcmVjdC53aWR0aCwgaGVpZ2h0OiByZWN0LmhlaWdodCB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBjZWxsIHNpemUgYmFzZWQgb24gZ3JpZCB3aWR0aCBhbmQgY29sdW1uc1xuICAgICAgICBjb25zdCBjb2xzID0gZ2V0R3JpZENvbHVtbnMoKTtcbiAgICAgICAgY29uc3QgZ2FwU2l6ZSA9IGdldEdhcCgpO1xuICAgICAgICBjb25zdCB0b3RhbEdhcFdpZHRoID0gZ2FwU2l6ZSAqIChjb2xzIC0gMSk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gcmVjdC53aWR0aCAtIHRvdGFsR2FwV2lkdGg7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDZWxsU2l6ZSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlV2lkdGggLyBjb2xzKTtcbiAgICAgICAgc2V0Q2VsbFNpemUoY2FsY3VsYXRlZENlbGxTaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGNhbGN1bGF0ZURpbWVuc2lvbnMoKTtcbiAgICBcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihjYWxjdWxhdGVEaW1lbnNpb25zKTtcbiAgICBpZiAoZ3JpZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGdyaWRSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBjYWxjdWxhdGVEaW1lbnNpb25zKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNhbGN1bGF0ZURpbWVuc2lvbnMpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50TGF5b3V0XSk7XG5cbiAgLy8gRWZmZWN0IHRvIGZpeCBjYXJkIHBvc2l0aW9ucyB3aGVuIGxheW91dCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtb3VudGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gVsOpcmlmaWVyIHNpIGRlcyBjYXJ0ZXMgb250IGRlcyBwb3NpdGlvbnMgaW52YWxpZGVzIHBvdXIgbGUgbGF5b3V0IGFjdHVlbFxuICAgIGNvbnN0IG1heENvbHMgPSBnZXRHcmlkQ29sdW1ucygpO1xuICAgIGNvbnN0IGNhcmRzVG9GaXggPSBjYXJkcy5maWx0ZXIoY2FyZCA9PiB7XG4gICAgICBpZiAoIWNhcmQuZ3JpZFBvc2l0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCB7IGNvbFNwYW4gfSA9IGdldENhcmRTaXplKGNhcmQpO1xuICAgICAgcmV0dXJuIGNhcmQuZ3JpZFBvc2l0aW9uLmNvbCArIGNvbFNwYW4gPiBtYXhDb2xzO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENvcnJpZ2VyIGxlcyBwb3NpdGlvbnMgaW52YWxpZGVzXG4gICAgY2FyZHNUb0ZpeC5mb3JFYWNoKGNhcmQgPT4ge1xuICAgICAgaWYgKGNhcmQuZ3JpZFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgY29sU3BhbiB9ID0gZ2V0Q2FyZFNpemUoY2FyZCk7XG4gICAgICAgIGNvbnN0IG5ld0NvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNhcmQuZ3JpZFBvc2l0aW9uLmNvbCwgbWF4Q29scyAtIGNvbFNwYW4pKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBGaXhpbmcgY2FyZCAke2NhcmQuaWR9OiBjb2wgJHtjYXJkLmdyaWRQb3NpdGlvbi5jb2x9IC0+ICR7bmV3Q29sfSwgY29sU3BhbjogJHtjb2xTcGFufSwgbWF4Q29sczogJHttYXhDb2xzfWApO1xuICAgICAgICBcbiAgICAgICAgdXBkYXRlQ2FyZChjYXJkLmlkLCB7XG4gICAgICAgICAgZ3JpZFBvc2l0aW9uOiB7IC4uLmNhcmQuZ3JpZFBvc2l0aW9uLCBjb2w6IG5ld0NvbCB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbY3VycmVudExheW91dCwgbW91bnRlZCwgY2FyZHNdKTtcbiAgXG4gIC8vIERldGVybWluZSBudW1iZXIgb2YgY29sdW1ucyBiYXNlZCBvbiBsYXlvdXRcbiAgY29uc3QgZ2V0R3JpZENvbHVtbnMgPSAoKSA9PiB7XG4gICAgc3dpdGNoIChjdXJyZW50TGF5b3V0KSB7XG4gICAgICBjYXNlICdtb2JpbGUnOiByZXR1cm4gMjtcbiAgICAgIGNhc2UgJ3RhYmxldCc6IHJldHVybiA0O1xuICAgICAgY2FzZSAnZGVza3RvcCc6IGRlZmF1bHQ6IHJldHVybiAxMjtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBEZXRlcm1pbmUgbnVtYmVyIG9mIHJvd3MgYmFzZWQgb24gbGF5b3V0IC0gRklYRUQgVE8gNiBST1dTIE1BWFxuICBjb25zdCBnZXRHcmlkUm93cyA9ICgpID0+IHtcbiAgICBzd2l0Y2ggKGN1cnJlbnRMYXlvdXQpIHtcbiAgICAgIGNhc2UgJ21vYmlsZSc6IHJldHVybiA2O1xuICAgICAgY2FzZSAndGFibGV0JzogcmV0dXJuIDY7XG4gICAgICBjYXNlICdkZXNrdG9wJzogZGVmYXVsdDogcmV0dXJuIDY7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRGV0ZXJtaW5lIGdhcCBiYXNlZCBvbiBsYXlvdXRcbiAgY29uc3QgZ2V0R2FwID0gKCkgPT4ge1xuICAgIHN3aXRjaCAoY3VycmVudExheW91dCkge1xuICAgICAgY2FzZSAnbW9iaWxlJzogcmV0dXJuIDg7XG4gICAgICBjYXNlICd0YWJsZXQnOiByZXR1cm4gMTI7XG4gICAgICBjYXNlICdkZXNrdG9wJzogZGVmYXVsdDogcmV0dXJuIDE2O1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIENvbnZlcnQgY2FyZCBzaXplIHRvIGNvbHVtbiBhbmQgcm93IHNwYW4gLSBGSVhFRCBMT0dJQ1xuICBjb25zdCBnZXRDYXJkU2l6ZSA9IChjYXJkOiBCZW50b0NhcmQpID0+IHtcbiAgICBjb25zdCBbY29sU3Bhbiwgcm93U3Bhbl0gPSBjYXJkLnNpemUuc3BsaXQoJ3gnKS5tYXAoTnVtYmVyKTtcbiAgICBcbiAgICAvLyBEZWJ1ZzogTG9nIGxhIHRhaWxsZSBkZSBsYSBjYXJ0ZVxuICAgIGNvbnNvbGUubG9nKGBDYXJkICR7Y2FyZC5pZH0gc2l6ZTogJHtjYXJkLnNpemV9IC0+IGNvbFNwYW46ICR7Y29sU3Bhbn0sIHJvd1NwYW46ICR7cm93U3Bhbn0sIGxheW91dDogJHtjdXJyZW50TGF5b3V0fWApO1xuICAgIFxuICAgIC8vIEFkYXB0IHNpemUgYmFzZWQgb24gbGF5b3V0XG4gICAgaWYgKGN1cnJlbnRMYXlvdXQgPT09ICdtb2JpbGUnKSB7XG4gICAgICAvLyBPbiBtb2JpbGUsIGxpbWl0IHRvIDIgY29sdW1ucyBtYXhcbiAgICAgIGNvbnN0IGFkYXB0ZWRDb2xTcGFuID0gTWF0aC5taW4oY29sU3BhbiwgMik7XG4gICAgICByZXR1cm4geyBjb2xTcGFuOiBhZGFwdGVkQ29sU3Bhbiwgcm93U3BhbiB9O1xuICAgIH0gZWxzZSBpZiAoY3VycmVudExheW91dCA9PT0gJ3RhYmxldCcpIHtcbiAgICAgIC8vIE9uIHRhYmxldCwgbGltaXQgdG8gNCBjb2x1bW5zIG1heFxuICAgICAgY29uc3QgYWRhcHRlZENvbFNwYW4gPSBNYXRoLm1pbihjb2xTcGFuLCA0KTtcbiAgICAgIHJldHVybiB7IGNvbFNwYW46IGFkYXB0ZWRDb2xTcGFuLCByb3dTcGFuIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9uIGRlc2t0b3AsIHVzZSB0aGUgYWN0dWFsIHNpemUgZnJvbSBjYXJkLnNpemVcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBjb2xTcGFuOiBNYXRoLm1pbihjb2xTcGFuLCAxMiksIFxuICAgICAgICByb3dTcGFuOiBNYXRoLm1pbihyb3dTcGFuLCA2KSBcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBcbiAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnNcbiAgY29uc3QgaGFzQ29sbGlzaW9uID0gKGNhcmRJZDogc3RyaW5nLCBjb2w6IG51bWJlciwgcm93OiBudW1iZXIsIGNvbFNwYW46IG51bWJlciwgcm93U3BhbjogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgLy8gQ2hlY2sgZ3JpZCBib3VuZGFyaWVzXG4gICAgaWYgKGNvbCA8IDAgfHwgcm93IDwgMCB8fCBjb2wgKyBjb2xTcGFuID4gZ2V0R3JpZENvbHVtbnMoKSB8fCByb3cgKyByb3dTcGFuID4gZ2V0R3JpZFJvd3MoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGZvciAoY29uc3QgY2FyZCBvZiBjYXJkcykge1xuICAgICAgaWYgKGNhcmQuaWQgPT09IGNhcmRJZCB8fCAhY2FyZC5ncmlkUG9zaXRpb24pIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCB7IGNvbFNwYW46IGNhcmRDb2xTcGFuLCByb3dTcGFuOiBjYXJkUm93U3BhbiB9ID0gZ2V0Q2FyZFNpemUoY2FyZCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHJlY3RhbmdsZXMgb3ZlcmxhcFxuICAgICAgY29uc3Qgb3ZlcmxhcCA9ICEoXG4gICAgICAgIGNvbCA+PSBjYXJkLmdyaWRQb3NpdGlvbi5jb2wgKyBjYXJkQ29sU3BhbiB8fCAvLyBSaWdodFxuICAgICAgICBjb2wgKyBjb2xTcGFuIDw9IGNhcmQuZ3JpZFBvc2l0aW9uLmNvbCB8fCAgICAgLy8gTGVmdFxuICAgICAgICByb3cgPj0gY2FyZC5ncmlkUG9zaXRpb24ucm93ICsgY2FyZFJvd1NwYW4gfHwgLy8gQm90dG9tXG4gICAgICAgIHJvdyArIHJvd1NwYW4gPD0gY2FyZC5ncmlkUG9zaXRpb24ucm93ICAgICAgICAvLyBUb3BcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChvdmVybGFwKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIEludGVsbGlnZW50IHJlc2l6ZSBmdW5jdGlvblxuICBjb25zdCBoYW5kbGVJbnRlbGxpZ2VudFJlc2l6ZSA9IChjYXJkSWQ6IHN0cmluZywgbmV3Q29sczogbnVtYmVyLCBuZXdSb3dzOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBjYXJkID0gY2FyZHMuZmluZChjID0+IGMuaWQgPT09IGNhcmRJZCk7XG4gICAgaWYgKCFjYXJkIHx8ICFjYXJkLmdyaWRQb3NpdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGNvbnN0IGN1cnJlbnRDb2wgPSBjYXJkLmdyaWRQb3NpdGlvbi5jb2w7XG4gICAgY29uc3QgY3VycmVudFJvdyA9IGNhcmQuZ3JpZFBvc2l0aW9uLnJvdztcbiAgICBcbiAgICAvLyBDaGVjayBncmlkIGxpbWl0c1xuICAgIGlmIChjdXJyZW50Q29sICsgbmV3Q29scyA+IGdldEdyaWRDb2x1bW5zKCkgfHwgY3VycmVudFJvdyArIG5ld1Jvd3MgPiBnZXRHcmlkUm93cygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zXG4gICAgaWYgKGhhc0NvbGxpc2lvbihjYXJkSWQsIGN1cnJlbnRDb2wsIGN1cnJlbnRSb3csIG5ld0NvbHMsIG5ld1Jvd3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgLy8gQ29udmVydCBjYXJkcyB0byBSZWFjdC1HcmlkLUxheW91dCBmb3JtYXRcbiAgY29uc3QgZ2V0TGF5b3V0SXRlbXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGNhcmRzLm1hcChjYXJkID0+IHtcbiAgICAgIGlmICghY2FyZC5ncmlkUG9zaXRpb24pIHJldHVybiBudWxsO1xuICAgICAgXG4gICAgICBjb25zdCB7IGNvbFNwYW4sIHJvd1NwYW4gfSA9IGdldENhcmRTaXplKGNhcmQpO1xuICAgICAgXG4gICAgICAvLyBERUJVRzogTG9nIGNhcmQgbGF5b3V0IGluZm9cbiAgICAgIGNvbnNvbGUubG9nKGBDYXJkICR7Y2FyZC5pZH0gbGF5b3V0OmAsIHtcbiAgICAgICAgc2l6ZTogY2FyZC5zaXplLFxuICAgICAgICBjb2xTcGFuLFxuICAgICAgICByb3dTcGFuLFxuICAgICAgICBwb3NpdGlvbjogY2FyZC5ncmlkUG9zaXRpb24sXG4gICAgICAgIGN1cnJlbnRMYXlvdXQsXG4gICAgICAgIGdyaWRDb2x1bW5zOiBnZXRHcmlkQ29sdW1ucygpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaTogY2FyZC5pZCxcbiAgICAgICAgeDogY2FyZC5ncmlkUG9zaXRpb24uY29sLFxuICAgICAgICB5OiBjYXJkLmdyaWRQb3NpdGlvbi5yb3csXG4gICAgICAgIHc6IGNvbFNwYW4sXG4gICAgICAgIGg6IHJvd1NwYW4sXG4gICAgICAgIHN0YXRpYzogaXNQcmV2aWV3LFxuICAgICAgICBtYXhXOiBnZXRHcmlkQ29sdW1ucygpLFxuICAgICAgICBtYXhIOiBnZXRHcmlkUm93cygpXG4gICAgICB9O1xuICAgIH0pLmZpbHRlcihCb29sZWFuKSBhcyBHcmlkTGF5b3V0LkxheW91dFtdO1xuICB9O1xuICBcbiAgLy8gSGFuZGxlIGxheW91dCBjaGFuZ2UgZnJvbSBSZWFjdC1HcmlkLUxheW91dFxuICBjb25zdCBoYW5kbGVMYXlvdXRDaGFuZ2UgPSAobGF5b3V0OiBHcmlkTGF5b3V0LkxheW91dFtdKSA9PiB7XG4gICAgaWYgKGlzUHJldmlldyB8fCBpc0xheW91dENoYW5naW5nKSByZXR1cm47XG4gICAgXG4gICAgLy8gU2V0IGEgZmxhZyB0byBwcmV2ZW50IG11bHRpcGxlIHVwZGF0ZXNcbiAgICBzZXRJc0xheW91dENoYW5naW5nKHRydWUpO1xuICAgIFxuICAgIC8vIFByb2Nlc3MgbGF5b3V0IGNoYW5nZXMgb25lIGJ5IG9uZSB0byBwcmV2ZW50IGNhc2NhZGluZyB1cGRhdGVzXG4gICAgY29uc3QgdXBkYXRlcyA9IGxheW91dC5tYXAoaXRlbSA9PiB7XG4gICAgICBjb25zdCBjYXJkID0gY2FyZHMuZmluZChjID0+IGMuaWQgPT09IGl0ZW0uaSk7XG4gICAgICBpZiAoY2FyZCAmJiBjYXJkLmdyaWRQb3NpdGlvbikge1xuICAgICAgICBpZiAoY2FyZC5ncmlkUG9zaXRpb24uY29sICE9PSBpdGVtLnggfHwgY2FyZC5ncmlkUG9zaXRpb24ucm93ICE9PSBpdGVtLnkpIHtcbiAgICAgICAgICByZXR1cm4geyBpZDogY2FyZC5pZCwgeDogaXRlbS54LCB5OiBpdGVtLnkgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIFxuICAgIC8vIEFwcGx5IHVwZGF0ZXMgc2VxdWVudGlhbGx5XG4gICAgaWYgKHVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gT25seSB1cGRhdGUgdGhlIGNhcmQgdGhhdCB3YXMgYWN0dWFsbHkgbW92ZWQgYnkgdGhlIHVzZXJcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IHVwZGF0ZXNbMF07XG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHVwZGF0ZUNhcmQodXBkYXRlLmlkLCB7XG4gICAgICAgICAgZ3JpZFBvc2l0aW9uOiB7IGNvbDogdXBkYXRlLngsIHJvdzogdXBkYXRlLnkgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmVzZXQgdGhlIGZsYWcgYWZ0ZXIgYSBzaG9ydCBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0SXNMYXlvdXRDaGFuZ2luZyhmYWxzZSk7XG4gICAgfSwgMTAwKTtcbiAgfTtcblxuICAvLyBDaGVjayBpZiBhIGNlbGwgaXMgZnJlZSAobm90IG9jY3VwaWVkIGJ5IGFueSBjYXJkKVxuICBjb25zdCBpc0NlbGxGcmVlID0gKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcikgPT4ge1xuICAgIGlmIChyb3cgPj0gZ2V0R3JpZFJvd3MoKSB8fCBjb2wgPj0gZ2V0R3JpZENvbHVtbnMoKSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGFueSBjYXJkIG9jY3VwaWVzIHRoaXMgY2VsbFxuICAgIGZvciAoY29uc3QgY2FyZCBvZiBjYXJkcykge1xuICAgICAgaWYgKCFjYXJkLmdyaWRQb3NpdGlvbikgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgY29sU3Bhbiwgcm93U3BhbiB9ID0gZ2V0Q2FyZFNpemUoY2FyZCk7XG4gICAgICBjb25zdCBjYXJkU3RhcnRDb2wgPSBjYXJkLmdyaWRQb3NpdGlvbi5jb2w7XG4gICAgICBjb25zdCBjYXJkRW5kQ29sID0gY2FyZFN0YXJ0Q29sICsgY29sU3BhbiAtIDE7XG4gICAgICBjb25zdCBjYXJkU3RhcnRSb3cgPSBjYXJkLmdyaWRQb3NpdGlvbi5yb3c7XG4gICAgICBjb25zdCBjYXJkRW5kUm93ID0gY2FyZFN0YXJ0Um93ICsgcm93U3BhbiAtIDE7XG4gICAgICBcbiAgICAgIGlmIChjb2wgPj0gY2FyZFN0YXJ0Q29sICYmIGNvbCA8PSBjYXJkRW5kQ29sICYmIFxuICAgICAgICAgIHJvdyA+PSBjYXJkU3RhcnRSb3cgJiYgcm93IDw9IGNhcmRFbmRSb3cpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byBhZGQgYSBuZXcgY2FyZCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIC0gQ09SUkVDVEVEXG4gIGNvbnN0IGhhbmRsZUFkZENhcmQgPSBhc3luYyAodHlwZTogQmVudG9DYXJkWyd0eXBlJ10sIHBvc2l0aW9uPzogeyByb3c6IG51bWJlcjsgY29sOiBudW1iZXIgfSkgPT4ge1xuICAgIC8vIENoZWNrIGlmIHRoZSBjZWxsIGlzIGZyZWVcbiAgICBpZiAoIWlzQ2VsbEZyZWUocm93LCBjb2wpIHx8IGFkZGluZ0NhcmQpIHJldHVybjtcbiAgICBcbiAgICBzZXRBZGRpbmdDYXJkKHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBUYWlsbGUgYWRhcHTDqWUgYXUgbGF5b3V0IGFjdHVlbFxuICAgICAgbGV0IGNhcmRTaXplOiBzdHJpbmc7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRMYXlvdXQpIHtcbiAgICAgICAgY2FzZSAnbW9iaWxlJzpcbiAgICAgICAgICBjYXJkU2l6ZSA9ICcxeDEnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YWJsZXQnOlxuICAgICAgICAgIGNhcmRTaXplID0gJzJ4Mic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rlc2t0b3AnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhcmRTaXplID0gJzJ4Mic7IC8vIFRhaWxsZSBmaXhlIHBvdXIgZGVza3RvcFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGNhcmQgd2l0aCBzaXplOiAke2NhcmRTaXplfSBhdCBwb3NpdGlvbiAoJHtjb2x9LCAke3Jvd30pIGZvciBsYXlvdXQ6ICR7Y3VycmVudExheW91dH1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgbmV3Q2FyZDogUGFydGlhbDxCZW50b0NhcmQ+ID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzYzNjZmMScsXG4gICAgICAgIHRleHRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICBzaXplOiBjYXJkU2l6ZSBhcyBhbnksXG4gICAgICAgIGdyaWRQb3NpdGlvbjogZmluYWxQb3NpdGlvblxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWRkQ2FyZChuZXdDYXJkKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBhbGVydChyZXN1bHQuZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3BlbiBlZGl0b3IgZm9yIHRoZSBuZXcgY2FyZFxuICAgICAgICBvbkNhcmRDbGljayAmJiBvbkNhcmRDbGljayhyZXN1bHQuY2FyZElkIHx8ICcnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyBjYXJkOlwiLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEFkZGluZ0NhcmQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGVjayBwbGFuIGxpbWl0c1xuICBjb25zdCBjYW5BZGRNb3JlQ2FyZHMgPSAoKSA9PiB7XG4gICAgaWYgKHVzZXJQbGFuID09PSAnZnJlZScpIHJldHVybiBjYXJkcy5sZW5ndGggPCAzO1xuICAgIGlmICh1c2VyUGxhbiA9PT0gJ3N0YXJ0ZXInKSByZXR1cm4gY2FyZHMubGVuZ3RoIDwgMjU7XG4gICAgcmV0dXJuIHRydWU7IC8vIFBybyBwbGFuID0gdW5saW1pdGVkXG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlIGdyaWQgaGVpZ2h0IGJhc2VkIG9uIGNvbnRlbnRcbiAgY29uc3QgZ3JpZEhlaWdodCA9IGdldEdyaWRSb3dzKCkgKiBjZWxsU2l6ZSArIChnZXRHcmlkUm93cygpIC0gMSkgKiBnZXRHYXAoKTtcblxuICAvLyBDYWxjdWxhdGUgYWxsIGVtcHR5IGNlbGxzIGZvciB0aGUgZ3JpZCAtIEZJWEVEXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWF4Q29scyA9IGdldEdyaWRDb2x1bW5zKCk7XG4gICAgY29uc3QgbWF4Um93cyA9IGdldEdyaWRSb3dzKCk7XG4gICAgY29uc3QgZW1wdHlDZWxsczoge3JvdzogbnVtYmVyLCBjb2w6IG51bWJlcn1bXSA9IFtdO1xuICAgIFxuICAgIC8vIENoZWNrIGVhY2ggY2VsbCBpbiB0aGUgZ3JpZFxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1heFJvd3M7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBtYXhDb2xzOyBjb2wrKykge1xuICAgICAgICBpZiAoaXNDZWxsRnJlZShyb3csIGNvbCkpIHtcbiAgICAgICAgICAvLyBMb2dpcXVlIGFkYXB0w6llIGF1IGxheW91dFxuICAgICAgICAgIGlmIChjdXJyZW50TGF5b3V0ID09PSAnZGVza3RvcCcpIHtcbiAgICAgICAgICAgIC8vIFBvdXIgZGVza3RvcCwgdsOpcmlmaWVyIGwnZXNwYWNlIHBvdXIgdW5lIGNhcnRlIDJ4MlxuICAgICAgICAgICAgbGV0IGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVsOpcmlmaWVyIHNpIG9uIGEgYXNzZXogZCdlc3BhY2UgKDJ4MilcbiAgICAgICAgICAgIGlmIChjb2wgKyAyID4gbWF4Q29scyB8fCByb3cgKyAyID4gbWF4Um93cykge1xuICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVsOpcmlmaWVyIHF1ZSB0b3V0ZXMgbGVzIGNlbGx1bGVzIG7DqWNlc3NhaXJlcyBzb250IGxpYnJlc1xuICAgICAgICAgICAgICBmb3IgKGxldCByID0gcm93OyByIDwgcm93ICsgMjsgcisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNvbDsgYyA8IGNvbCArIDI7IGMrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc0NlbGxGcmVlKHIsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NwYWNlKSBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGFzU3BhY2UpIHtcbiAgICAgICAgICAgICAgZW1wdHlDZWxscy5wdXNoKHsgcm93LCBjb2wgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGF5b3V0ID09PSAndGFibGV0Jykge1xuICAgICAgICAgICAgLy8gUG91ciB0YWJsZXQsIHbDqXJpZmllciBsJ2VzcGFjZSBwb3VyIHVuZSBjYXJ0ZSAyeDJcbiAgICAgICAgICAgIGxldCBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChjb2wgKyAyID4gbWF4Q29scyB8fCByb3cgKyAyID4gbWF4Um93cykge1xuICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgciA9IHJvdzsgciA8IHJvdyArIDI7IHIrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjb2w7IGMgPCBjb2wgKyAyOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNDZWxsRnJlZShyLCBjKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNTcGFjZSkgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhhc1NwYWNlKSB7XG4gICAgICAgICAgICAgIGVtcHR5Q2VsbHMucHVzaCh7IHJvdywgY29sIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQb3VyIG1vYmlsZSwgYWpvdXRlciBkaXJlY3RlbWVudCAoMXgxKVxuICAgICAgICAgICAgZW1wdHlDZWxscy5wdXNoKHsgcm93LCBjb2wgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHNldEVtcHR5R3JpZENlbGxzKGVtcHR5Q2VsbHMpO1xuICB9LCBbY2FyZHMsIGN1cnJlbnRMYXlvdXQsIG1vdW50ZWRdKTtcbiAgXG4gIC8vIFVzZSBmYWxsYmFjayB2YWx1ZXMgdG8gZW5zdXJlIEdyaWRMYXlvdXQgYWx3YXlzIHJlY2VpdmVzIHZhbGlkIHByb3BzXG4gIGNvbnN0IHNhZmVHcmlkV2lkdGggPSBncmlkRGltZW5zaW9ucy53aWR0aCB8fCAxMjAwO1xuICBjb25zdCBzYWZlQ2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAxMDA7XG5cbiAgaWYgKCFtb3VudGVkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtOTYgYmctZ3JheS0xMDAgcm91bmRlZC1sZyBhbmltYXRlLXB1bHNlIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMFwiPkxvYWRpbmcgZ3JpZC4uLjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuICBcbiAgcmV0dXJuIChcbiAgICA8ZGl2IFxuICAgICAgcmVmPXtncmlkUmVmfVxuICAgICAgY2xhc3NOYW1lPXtgcmVsYXRpdmUgdG91Y2gtbm9uZSB3LWZ1bGwgJHtjbGFzc05hbWV9YH1cbiAgICAgIHN0eWxlPXt7IFxuICAgICAgICBoZWlnaHQ6IGdyaWRIZWlnaHQsXG4gICAgICAgIG1pbkhlaWdodDogJzMwMHB4JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgIH19XG4gICAgPlxuICAgICAge2lzUHJldmlldyA/IChcbiAgICAgICAgLy8gUHJldmlldyBtb2RlIC0gc3RhdGljIGdyaWRcbiAgICAgICAgPGRpdlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBgcmVwZWF0KCR7Z2V0R3JpZENvbHVtbnMoKX0sIDFmcilgLFxuICAgICAgICAgICAgZ3JpZFRlbXBsYXRlUm93czogYHJlcGVhdCgke2dldEdyaWRSb3dzKCl9LCAxZnIpYCxcbiAgICAgICAgICAgIGdhcDogYCR7Z2V0R2FwKCl9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtjYXJkcy5tYXAoKGNhcmQpID0+IHtcbiAgICAgICAgICAgIGlmICghY2FyZC5ncmlkUG9zaXRpb24pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZXQgZ3JpZCBzcGFuXG4gICAgICAgICAgICBjb25zdCB7IGNvbFNwYW4sIHJvd1NwYW4gfSA9IGdldENhcmRTaXplKGNhcmQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIGtleT17Y2FyZC5pZH1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogYCR7Y2FyZC5ncmlkUG9zaXRpb24uY29sICsgMX0gLyBzcGFuICR7Y29sU3Bhbn1gLFxuICAgICAgICAgICAgICAgICAgZ3JpZFJvdzogYCR7Y2FyZC5ncmlkUG9zaXRpb24ucm93ICsgMX0gLyBzcGFuICR7cm93U3Bhbn1gLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPEJlbnRvQ2FyZENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgY2FyZD17Y2FyZH1cbiAgICAgICAgICAgICAgICAgIGlzUHJldmlld01vZGU9e3RydWV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPEdyaWRMYXlvdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImxheW91dFwiXG4gICAgICAgICAgICBsYXlvdXQ9e2dldExheW91dEl0ZW1zKCl9XG4gICAgICAgICAgICBjb2xzPXtnZXRHcmlkQ29sdW1ucygpfVxuICAgICAgICAgICAgcm93SGVpZ2h0PXtzYWZlQ2VsbFNpemV9XG4gICAgICAgICAgICB3aWR0aD17c2FmZUdyaWRXaWR0aH1cbiAgICAgICAgICAgIG1hcmdpbj17W2dldEdhcCgpLCBnZXRHYXAoKV19XG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nPXtbMCwgMF19XG4gICAgICAgICAgICBvbkxheW91dENoYW5nZT17aGFuZGxlTGF5b3V0Q2hhbmdlfVxuICAgICAgICAgICAgaXNEcmFnZ2FibGU9eyFpc1ByZXZpZXcgJiYgY3VycmVudExheW91dCA9PT0gJ2Rlc2t0b3AnfVxuICAgICAgICAgICAgaXNSZXNpemFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgY29tcGFjdFR5cGU9e251bGx9XG4gICAgICAgICAgICBwcmV2ZW50Q29sbGlzaW9uPXt0cnVlfVxuICAgICAgICAgICAgdXNlQ1NTVHJhbnNmb3Jtcz17dHJ1ZX1cbiAgICAgICAgICAgIGRyYWdnYWJsZUhhbmRsZT1cIi5kcmFnLWhhbmRsZVwiXG4gICAgICAgICAgICBtYXhSb3dzPXtnZXRHcmlkUm93cygpfVxuICAgICAgICAgICAgcmVzaXplSGFuZGxlcz17W119XG4gICAgICAgICAgICBhdXRvU2l6ZT17ZmFsc2V9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NhcmRzLm1hcCgoY2FyZCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWNhcmQuZ3JpZFBvc2l0aW9uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9e2NhcmQuaWR9IGNsYXNzTmFtZT1cImgtZnVsbCB3LWZ1bGxcIj5cbiAgICAgICAgICAgICAgICAgIDxSZXNpemFibGVDYXJkXG4gICAgICAgICAgICAgICAgICAgIGNhcmQ9e2NhcmR9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxTaXplPXtzYWZlQ2VsbFNpemV9XG4gICAgICAgICAgICAgICAgICAgIGdhcD17Z2V0R2FwKCl9XG4gICAgICAgICAgICAgICAgICAgIG1heENvbHM9e2dldEdyaWRDb2x1bW5zKCl9XG4gICAgICAgICAgICAgICAgICAgIG1heFJvd3M9e2dldEdyaWRSb3dzKCl9XG4gICAgICAgICAgICAgICAgICAgIG9uSW50ZWxsaWdlbnRSZXNpemU9e2hhbmRsZUludGVsbGlnZW50UmVzaXplfVxuICAgICAgICAgICAgICAgICAgICBvbkVkaXQ9eygpID0+IG9uQ2FyZENsaWNrICYmIG9uQ2FyZENsaWNrKGNhcmQuaWQpfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvR3JpZExheW91dD5cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogRW1wdHkgY2VsbCBncmlkIGZvciBhZGRpbmcgbmV3IGNhcmRzICovfVxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgcG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IGByZXBlYXQoJHtnZXRHcmlkQ29sdW1ucygpfSwgMWZyKWAsXG4gICAgICAgICAgICAgIGdyaWRUZW1wbGF0ZVJvd3M6IGByZXBlYXQoJHtnZXRHcmlkUm93cygpfSwgMWZyKWAsXG4gICAgICAgICAgICAgIGdhcDogYCR7Z2V0R2FwKCl9cHhgLFxuICAgICAgICAgICAgICB6SW5kZXg6IDVcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2VtcHR5R3JpZENlbGxzLm1hcCgoeyByb3csIGNvbCB9KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IGhvdmVyZWRDZWxsPy5yb3cgPT09IHJvdyAmJiBob3ZlcmVkQ2VsbD8uY29sID09PSBjb2w7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGtleT17YGNlbGwtJHtyb3d9LSR7Y29sfWB9XG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBncmlkQ29sdW1uOiBjb2wgKyAxLFxuICAgICAgICAgICAgICAgICAgICBncmlkUm93OiByb3cgKyAxLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImN1cnNvci1wb2ludGVyIHBvaW50ZXItZXZlbnRzLWF1dG9cIlxuICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoKSA9PiBzZXRIb3ZlcmVkQ2VsbCh7IHJvdywgY29sIH0pfVxuICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRIb3ZlcmVkQ2VsbChudWxsKX1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUFkZENhcmQocm93LCBjb2wpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHsvKiBFbXB0eSBjZWxsIHdpdGggaG92ZXIgZWZmZWN0ICovfVxuICAgICAgICAgICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGU9e3sgXG4gICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogaXNIb3ZlcmVkID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IGlzSG92ZXJlZCA/IDEgOiAwLjhcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCByb3VuZGVkLWxnIGJvcmRlci0yIGJvcmRlci1kYXNoZWQgYm9yZGVyLWluZGlnby01MDAvNDAgYmctaW5kaWdvLTUwMC8xMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGVIb3Zlcj17eyBzY2FsZTogMS4xIH19XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGVUYXA9e3sgc2NhbGU6IDAuOSB9fVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHAtMiByb3VuZGVkLWZ1bGwgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkFkZE1vcmVDYXJkcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2JnLWluZGlnby01MDAgdGV4dC13aGl0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYmctcmVkLTUwMCB0ZXh0LXdoaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAge2NhbkFkZE1vcmVDYXJkcygpID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPFBsdXMgc2l6ZT17MTZ9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDcm93biBzaXplPXsxNn0gLz5cbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L21vdGlvbi5kaXY+XG4gICAgICAgICAgICAgICAgICA8L21vdGlvbi5kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQmVudG9HcmlkOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwibW90aW9uIiwidXNlU3RvcmUiLCJCZW50b0NhcmRDb21wb25lbnQiLCJQbHVzIiwiQ3Jvd24iLCJHcmlkTGF5b3V0IiwiUmVzaXphYmxlQ2FyZCIsIkJlbnRvR3JpZCIsImNhcmRzIiwiaXNQcmV2aWV3Iiwib25DYXJkQ2xpY2siLCJjbGFzc05hbWUiLCJjdXJyZW50TGF5b3V0IiwidXBkYXRlQ2FyZCIsImFkZENhcmQiLCJ1c2VyUGxhbiIsImdyaWREaW1lbnNpb25zIiwic2V0R3JpZERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsImNlbGxTaXplIiwic2V0Q2VsbFNpemUiLCJob3ZlcmVkQ2VsbCIsInNldEhvdmVyZWRDZWxsIiwiZ3JpZFJlZiIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwiaXNMYXlvdXRDaGFuZ2luZyIsInNldElzTGF5b3V0Q2hhbmdpbmciLCJhZGRpbmdDYXJkIiwic2V0QWRkaW5nQ2FyZCIsImVtcHR5R3JpZENlbGxzIiwic2V0RW1wdHlHcmlkQ2VsbHMiLCJjYWxjdWxhdGVEaW1lbnNpb25zIiwiY3VycmVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb2xzIiwiZ2V0R3JpZENvbHVtbnMiLCJnYXBTaXplIiwiZ2V0R2FwIiwidG90YWxHYXBXaWR0aCIsImF2YWlsYWJsZVdpZHRoIiwiY2FsY3VsYXRlZENlbGxTaXplIiwiTWF0aCIsImZsb29yIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtYXhDb2xzIiwiY2FyZHNUb0ZpeCIsImZpbHRlciIsImNhcmQiLCJncmlkUG9zaXRpb24iLCJjb2xTcGFuIiwiZ2V0Q2FyZFNpemUiLCJjb2wiLCJmb3JFYWNoIiwibmV3Q29sIiwibWF4IiwibWluIiwiY29uc29sZSIsImxvZyIsImlkIiwiZ2V0R3JpZFJvd3MiLCJyb3dTcGFuIiwic2l6ZSIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwiYWRhcHRlZENvbFNwYW4iLCJoYXNDb2xsaXNpb24iLCJjYXJkSWQiLCJyb3ciLCJjYXJkQ29sU3BhbiIsImNhcmRSb3dTcGFuIiwib3ZlcmxhcCIsImhhbmRsZUludGVsbGlnZW50UmVzaXplIiwibmV3Q29scyIsIm5ld1Jvd3MiLCJmaW5kIiwiYyIsImN1cnJlbnRDb2wiLCJjdXJyZW50Um93IiwiZ2V0TGF5b3V0SXRlbXMiLCJwb3NpdGlvbiIsImdyaWRDb2x1bW5zIiwiaSIsIngiLCJ5IiwidyIsImgiLCJzdGF0aWMiLCJtYXhXIiwibWF4SCIsIkJvb2xlYW4iLCJoYW5kbGVMYXlvdXRDaGFuZ2UiLCJsYXlvdXQiLCJ1cGRhdGVzIiwiaXRlbSIsImxlbmd0aCIsInVwZGF0ZSIsInNldFRpbWVvdXQiLCJpc0NlbGxGcmVlIiwiY2FyZFN0YXJ0Q29sIiwiY2FyZEVuZENvbCIsImNhcmRTdGFydFJvdyIsImNhcmRFbmRSb3ciLCJoYW5kbGVBZGRDYXJkIiwidHlwZSIsImNhcmRTaXplIiwibmV3Q2FyZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ1cmwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ0ZXh0Q29sb3IiLCJmaW5hbFBvc2l0aW9uIiwicmVzdWx0Iiwic3VjY2VzcyIsImFsZXJ0IiwiZXJyb3IiLCJjYW5BZGRNb3JlQ2FyZHMiLCJncmlkSGVpZ2h0IiwibWF4Um93cyIsImVtcHR5Q2VsbHMiLCJoYXNTcGFjZSIsInIiLCJwdXNoIiwic2FmZUdyaWRXaWR0aCIsInNhZmVDZWxsU2l6ZSIsImRpdiIsInJlZiIsInN0eWxlIiwibWluSGVpZ2h0IiwiZGlzcGxheSIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJncmlkVGVtcGxhdGVSb3dzIiwiZ2FwIiwiZ3JpZENvbHVtbiIsImdyaWRSb3ciLCJpc1ByZXZpZXdNb2RlIiwicm93SGVpZ2h0IiwibWFyZ2luIiwiY29udGFpbmVyUGFkZGluZyIsIm9uTGF5b3V0Q2hhbmdlIiwiaXNEcmFnZ2FibGUiLCJpc1Jlc2l6YWJsZSIsImNvbXBhY3RUeXBlIiwicHJldmVudENvbGxpc2lvbiIsInVzZUNTU1RyYW5zZm9ybXMiLCJkcmFnZ2FibGVIYW5kbGUiLCJyZXNpemVIYW5kbGVzIiwiYXV0b1NpemUiLCJvbkludGVsbGlnZW50UmVzaXplIiwib25FZGl0IiwiekluZGV4IiwiaXNIb3ZlcmVkIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25DbGljayIsImluaXRpYWwiLCJvcGFjaXR5IiwiYW5pbWF0ZSIsInNjYWxlIiwid2hpbGVIb3ZlciIsIndoaWxlVGFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/BentoGrid.tsx\n"));

/***/ })

});
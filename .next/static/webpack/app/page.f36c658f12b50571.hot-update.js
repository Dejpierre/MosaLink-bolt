"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/BentoGrid.tsx":
/*!**************************************!*\
  !*** ./src/components/BentoGrid.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BentoGrid: function() { return /* binding */ BentoGrid; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/dom/motion.mjs\");\n/* harmony import */ var _store_useStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/useStore */ \"(app-pages-browser)/./src/store/useStore.ts\");\n/* harmony import */ var _BentoCardComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BentoCardComponent */ \"(app-pages-browser)/./src/components/BentoCardComponent.tsx\");\n/* harmony import */ var _barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Crown,Plus!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/plus.js\");\n/* harmony import */ var _barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Crown,Plus!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/crown.js\");\n/* harmony import */ var react_grid_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-grid-layout */ \"(app-pages-browser)/./node_modules/react-grid-layout/index.js\");\n/* harmony import */ var react_grid_layout__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_grid_layout__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_grid_layout_css_styles_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-grid-layout/css/styles.css */ \"(app-pages-browser)/./node_modules/react-grid-layout/css/styles.css\");\n/* harmony import */ var _ResizableCard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ResizableCard */ \"(app-pages-browser)/./src/components/ResizableCard.tsx\");\n/* __next_internal_client_entry_do_not_use__ BentoGrid,default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst BentoGrid = (param)=>{\n    let { cards, isPreview = false, onCardClick, className = \"\" } = param;\n    _s();\n    const { currentLayout, updateCard, addCard, userPlan } = (0,_store_useStore__WEBPACK_IMPORTED_MODULE_2__.useStore)();\n    const [gridDimensions, setGridDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [cellSize, setCellSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(100);\n    const [hoveredCell, setHoveredCell] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const gridRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLayoutChanging, setIsLayoutChanging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [addingCard, setAddingCard] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [emptyGridCells, setEmptyGridCells] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Calculate grid dimensions on mount and resize\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setMounted(true);\n        const calculateDimensions = ()=>{\n            if (gridRef.current) {\n                const rect = gridRef.current.getBoundingClientRect();\n                setGridDimensions({\n                    width: rect.width,\n                    height: rect.height\n                });\n                // Calculate cell size based on grid width and columns\n                const cols = getGridColumns();\n                const gapSize = getGap();\n                const totalGapWidth = gapSize * (cols - 1);\n                const availableWidth = rect.width - totalGapWidth;\n                const calculatedCellSize = Math.floor(availableWidth / cols);\n                setCellSize(calculatedCellSize);\n            }\n        };\n        calculateDimensions();\n        const resizeObserver = new ResizeObserver(calculateDimensions);\n        if (gridRef.current) {\n            resizeObserver.observe(gridRef.current);\n        }\n        window.addEventListener(\"resize\", calculateDimensions);\n        return ()=>{\n            resizeObserver.disconnect();\n            window.removeEventListener(\"resize\", calculateDimensions);\n        };\n    }, [\n        currentLayout\n    ]);\n    // Determine number of columns based on layout\n    const getGridColumns = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 2;\n            case \"tablet\":\n                return 4;\n            case \"desktop\":\n            default:\n                return 12;\n        }\n    };\n    // Determine number of rows based on layout - FIXED TO 6 ROWS MAX\n    const getGridRows = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 6;\n            case \"tablet\":\n                return 6;\n            case \"desktop\":\n            default:\n                return 6;\n        }\n    };\n    // Determine gap based on layout\n    const getGap = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 8;\n            case \"tablet\":\n                return 12;\n            case \"desktop\":\n            default:\n                return 16;\n        }\n    };\n    // Convert card size to column and row span - FIXED LOGIC\n    const getCardSize = (card)=>{\n        const [colSpan, rowSpan] = card.size.split(\"x\").map(Number);\n        // Adapt size based on layout\n        if (currentLayout === \"mobile\") {\n            // On mobile, limit to 2 columns max\n            const adaptedColSpan = Math.min(colSpan, 2);\n            return {\n                colSpan: adaptedColSpan,\n                rowSpan\n            };\n        } else if (currentLayout === \"tablet\") {\n            // On tablet, limit to 4 columns max\n            const adaptedColSpan = Math.min(colSpan, 4);\n            return {\n                colSpan: adaptedColSpan,\n                rowSpan\n            };\n        } else {\n            // CORRECTION: On desktop, use the actual size from card.size, don't modify it\n            return {\n                colSpan: Math.min(colSpan, 12),\n                rowSpan: Math.min(rowSpan, 6)\n            };\n        }\n    };\n    // Check for collisions\n    const hasCollision = (cardId, col, row, colSpan, rowSpan)=>{\n        // Check grid boundaries\n        if (col < 0 || row < 0 || col + colSpan > getGridColumns() || row + rowSpan > getGridRows()) {\n            return true;\n        }\n        for (const card of cards){\n            if (card.id === cardId || !card.gridPosition) continue;\n            const { colSpan: cardColSpan, rowSpan: cardRowSpan } = getCardSize(card);\n            // Check if rectangles overlap\n            const overlap = !(col >= card.gridPosition.col + cardColSpan || // Right\n            col + colSpan <= card.gridPosition.col || // Left\n            row >= card.gridPosition.row + cardRowSpan || // Bottom\n            row + rowSpan <= card.gridPosition.row // Top\n            );\n            if (overlap) return true;\n        }\n        return false;\n    };\n    // Intelligent resize function\n    const handleIntelligentResize = (cardId, newCols, newRows)=>{\n        const card = cards.find((c)=>c.id === cardId);\n        if (!card || !card.gridPosition) return false;\n        const currentCol = card.gridPosition.col;\n        const currentRow = card.gridPosition.row;\n        // Check grid limits\n        if (currentCol + newCols > getGridColumns() || currentRow + newRows > getGridRows()) {\n            return false;\n        }\n        // Check for collisions\n        if (hasCollision(cardId, currentCol, currentRow, newCols, newRows)) {\n            return false;\n        }\n        return true;\n    };\n    // Convert cards to React-Grid-Layout format\n    const getLayoutItems = ()=>{\n        return cards.map((card)=>{\n            if (!card.gridPosition) return null;\n            const { colSpan, rowSpan } = getCardSize(card);\n            return {\n                i: card.id,\n                x: card.gridPosition.col,\n                y: card.gridPosition.row,\n                w: colSpan,\n                h: rowSpan,\n                static: isPreview,\n                maxW: getGridColumns(),\n                maxH: getGridRows()\n            };\n        }).filter(Boolean);\n    };\n    // Handle layout change from React-Grid-Layout\n    const handleLayoutChange = (layout)=>{\n        if (isPreview || isLayoutChanging) return;\n        // Set a flag to prevent multiple updates\n        setIsLayoutChanging(true);\n        // Process layout changes one by one to prevent cascading updates\n        const updates = layout.map((item)=>{\n            const card = cards.find((c)=>c.id === item.i);\n            if (card && card.gridPosition) {\n                if (card.gridPosition.col !== item.x || card.gridPosition.row !== item.y) {\n                    return {\n                        id: card.id,\n                        x: item.x,\n                        y: item.y\n                    };\n                }\n            }\n            return null;\n        }).filter(Boolean);\n        // Apply updates sequentially\n        if (updates.length > 0) {\n            // Only update the card that was actually moved by the user\n            const update = updates[0];\n            if (update) {\n                updateCard(update.id, {\n                    gridPosition: {\n                        col: update.x,\n                        row: update.y\n                    }\n                });\n            }\n        }\n        // Reset the flag after a short delay\n        setTimeout(()=>{\n            setIsLayoutChanging(false);\n        }, 100);\n    };\n    // Check if a cell is free (not occupied by any card)\n    const isCellFree = (row, col)=>{\n        if (row >= getGridRows() || col >= getGridColumns()) return false;\n        // Check if any card occupies this cell\n        for (const card of cards){\n            if (!card.gridPosition) continue;\n            const { colSpan, rowSpan } = getCardSize(card);\n            const cardStartCol = card.gridPosition.col;\n            const cardEndCol = cardStartCol + colSpan - 1;\n            const cardStartRow = card.gridPosition.row;\n            const cardEndRow = cardStartRow + rowSpan - 1;\n            if (col >= cardStartCol && col <= cardEndCol && row >= cardStartRow && row <= cardEndRow) {\n                return false;\n            }\n        }\n        return true;\n    };\n    // Function to add a new card at a specific position - DEBUG\n    const handleAddCard = async (row, col)=>{\n        // DEBUG: Afficher les valeurs actuelles\n        console.log(\"\\uD83D\\uDD0D DEBUG handleAddCard:\");\n        console.log(\"currentLayout:\", currentLayout);\n        console.log(\"getGridColumns():\", getGridColumns());\n        console.log(\"Position demand\\xe9e:\", {\n            row,\n            col\n        });\n        // Check if the cell is free\n        if (!isCellFree(row, col) || addingCard) return;\n        setAddingCard(true);\n        try {\n            // CORRECTION: Force la bonne taille pour desktop\n            let cardSize;\n            switch(currentLayout){\n                case \"mobile\":\n                    cardSize = \"1x1\";\n                    break;\n                case \"tablet\":\n                    cardSize = \"1x1\";\n                    break;\n                case \"desktop\":\n                default:\n                    cardSize = \"2x2\"; // Forcer 2x2 pour desktop\n                    break;\n            }\n            const newCard = {\n                title: \"Nouvelle Carte\",\n                description: \"Cliquez pour \\xe9diter cette carte\",\n                url: \"\",\n                backgroundColor: \"#6366f1\",\n                textColor: \"#ffffff\",\n                size: cardSize,\n                gridPosition: {\n                    col,\n                    row\n                }\n            };\n            const result = await addCard(newCard);\n            if (!result.success) {\n                alert(result.error);\n            } else {\n                // Open editor for the new card\n                onCardClick && onCardClick(result.cardId || \"\");\n            }\n        } catch (error) {\n            console.error(\"Error adding card:\", error);\n        } finally{\n            setAddingCard(false);\n        }\n    };\n    // Check plan limits\n    const canAddMoreCards = ()=>{\n        if (userPlan === \"free\") return cards.length < 3;\n        if (userPlan === \"starter\") return cards.length < 25;\n        return true; // Pro plan = unlimited\n    };\n    // Calculate grid height based on content\n    const gridHeight = getGridRows() * cellSize + (getGridRows() - 1) * getGap();\n    // Calculate all empty cells for the grid - FIXED\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const maxCols = getGridColumns();\n        const maxRows = getGridRows();\n        const emptyCells = [];\n        // Check each cell in the grid\n        for(let row = 0; row < maxRows; row++){\n            for(let col = 0; col < maxCols; col++){\n                if (isCellFree(row, col)) {\n                    // CORRECTION: Logique plus simple et cohérente\n                    if (currentLayout === \"desktop\") {\n                        // Pour desktop, vérifier l'espace pour une carte 2x2\n                        let hasSpace = true;\n                        // Vérifier si on a assez d'espace (2x2)\n                        if (col + 2 > maxCols || row + 2 > maxRows) {\n                            hasSpace = false;\n                        } else {\n                            // Vérifier que toutes les cellules nécessaires sont libres\n                            for(let r = row; r < row + 2; r++){\n                                for(let c = col; c < col + 2; c++){\n                                    if (!isCellFree(r, c)) {\n                                        hasSpace = false;\n                                        break;\n                                    }\n                                }\n                                if (!hasSpace) break;\n                            }\n                        }\n                        if (hasSpace) {\n                            emptyCells.push({\n                                row,\n                                col\n                            });\n                        }\n                    } else {\n                        // Pour mobile et tablet, ajouter directement\n                        emptyCells.push({\n                            row,\n                            col\n                        });\n                    }\n                }\n            }\n        }\n        setEmptyGridCells(emptyCells);\n    }, [\n        cards,\n        currentLayout,\n        mounted\n    ]);\n    // Use fallback values to ensure GridLayout always receives valid props\n    const safeGridWidth = gridDimensions.width || 1;\n    const safeCellSize = cellSize || 1;\n    if (!mounted) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full h-96 bg-gray-100 rounded-lg animate-pulse flex items-center justify-center\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-gray-400\",\n                children: \"Loading grid...\"\n            }, void 0, false, {\n                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                lineNumber: 360,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n            lineNumber: 359,\n            columnNumber: 7\n        }, undefined);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: gridRef,\n        className: \"relative touch-none \".concat(className),\n        style: {\n            height: gridHeight,\n            minHeight: \"300px\",\n            position: \"relative\"\n        },\n        children: isPreview ? // Preview mode - static grid\n        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                display: \"grid\",\n                gridTemplateColumns: \"repeat(\".concat(getGridColumns(), \", 1fr)\"),\n                gridTemplateRows: \"repeat(\".concat(getGridRows(), \", 1fr)\"),\n                gap: \"\".concat(getGap(), \"px\"),\n                height: \"100%\",\n                width: \"100%\"\n            },\n            children: cards.map((card)=>{\n                if (!card.gridPosition) return null;\n                // Get grid span\n                const { colSpan, rowSpan } = getCardSize(card);\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        gridColumn: \"\".concat(card.gridPosition.col + 1, \" / span \").concat(colSpan),\n                        gridRow: \"\".concat(card.gridPosition.row + 1, \" / span \").concat(rowSpan),\n                        position: \"relative\"\n                    },\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_BentoCardComponent__WEBPACK_IMPORTED_MODULE_3__.BentoCardComponent, {\n                        card: card,\n                        isPreviewMode: true\n                    }, void 0, false, {\n                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                        lineNumber: 402,\n                        columnNumber: 17\n                    }, undefined)\n                }, card.id, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 394,\n                    columnNumber: 15\n                }, undefined);\n            })\n        }, void 0, false, {\n            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n            lineNumber: 377,\n            columnNumber: 9\n        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_grid_layout__WEBPACK_IMPORTED_MODULE_4___default()), {\n                    className: \"layout\",\n                    layout: getLayoutItems(),\n                    cols: getGridColumns(),\n                    rowHeight: safeCellSize,\n                    width: safeGridWidth,\n                    margin: [\n                        getGap(),\n                        getGap()\n                    ],\n                    containerPadding: [\n                        0,\n                        0\n                    ],\n                    onLayoutChange: handleLayoutChange,\n                    isDraggable: !isPreview && currentLayout === \"desktop\",\n                    isResizable: false,\n                    compactType: null,\n                    preventCollision: true,\n                    useCSSTransforms: true,\n                    draggableHandle: \".drag-handle\",\n                    maxRows: getGridRows(),\n                    resizeHandles: [],\n                    children: cards.map((card)=>{\n                        if (!card.gridPosition) return null;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"h-full w-full\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ResizableCard__WEBPACK_IMPORTED_MODULE_6__.ResizableCard, {\n                                card: card,\n                                cellSize: safeCellSize,\n                                gap: getGap(),\n                                maxCols: getGridColumns(),\n                                maxRows: getGridRows(),\n                                onIntelligentResize: handleIntelligentResize,\n                                onEdit: ()=>onCardClick && onCardClick(card.id)\n                            }, void 0, false, {\n                                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                lineNumber: 435,\n                                columnNumber: 19\n                            }, undefined)\n                        }, card.id, false, {\n                            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                            lineNumber: 434,\n                            columnNumber: 17\n                        }, undefined);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 412,\n                    columnNumber: 11\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute inset-0 pointer-events-none\",\n                    style: {\n                        display: \"grid\",\n                        gridTemplateColumns: \"repeat(\".concat(getGridColumns(), \", 1fr)\"),\n                        gridTemplateRows: \"repeat(\".concat(getGridRows(), \", 1fr)\"),\n                        gap: \"\".concat(getGap(), \"px\"),\n                        zIndex: 5\n                    },\n                    children: emptyGridCells.map((param)=>{\n                        let { row, col } = param;\n                        const isHovered = (hoveredCell === null || hoveredCell === void 0 ? void 0 : hoveredCell.row) === row && (hoveredCell === null || hoveredCell === void 0 ? void 0 : hoveredCell.col) === col;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                gridColumn: col + 1,\n                                gridRow: row + 1,\n                                position: \"relative\"\n                            },\n                            className: \"cursor-pointer pointer-events-auto\",\n                            onMouseEnter: ()=>setHoveredCell({\n                                    row,\n                                    col\n                                }),\n                            onMouseLeave: ()=>setHoveredCell(null),\n                            onClick: ()=>handleAddCard(row, col),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_7__.motion.div, {\n                                initial: {\n                                    opacity: 0\n                                },\n                                animate: {\n                                    opacity: isHovered ? 1 : 0,\n                                    scale: isHovered ? 1 : 0.8\n                                },\n                                className: \"absolute inset-0 rounded-lg border-2 border-dashed border-indigo-500/40 bg-indigo-500/10 flex items-center justify-center\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_7__.motion.div, {\n                                    whileHover: {\n                                        scale: 1.1\n                                    },\n                                    whileTap: {\n                                        scale: 0.9\n                                    },\n                                    className: \"p-2 rounded-full \".concat(canAddMoreCards() ? \"bg-indigo-500 text-white\" : \"bg-red-500 text-white\"),\n                                    children: canAddMoreCards() ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                        size: 16\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                        lineNumber: 495,\n                                        columnNumber: 25\n                                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                        size: 16\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                        lineNumber: 497,\n                                        columnNumber: 25\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                    lineNumber: 485,\n                                    columnNumber: 21\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                lineNumber: 477,\n                                columnNumber: 19\n                            }, undefined)\n                        }, \"cell-\".concat(row, \"-\").concat(col), false, {\n                            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                            lineNumber: 464,\n                            columnNumber: 17\n                        }, undefined);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 450,\n                    columnNumber: 11\n                }, undefined)\n            ]\n        }, void 0, true)\n    }, void 0, false, {\n        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n        lineNumber: 366,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BentoGrid, \"s7/xGUKjl5RzpRMxEcelZleSZs0=\", false, function() {\n    return [\n        _store_useStore__WEBPACK_IMPORTED_MODULE_2__.useStore\n    ];\n});\n_c = BentoGrid;\n/* harmony default export */ __webpack_exports__[\"default\"] = (BentoGrid);\nvar _c;\n$RefreshReg$(_c, \"BentoGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0JlbnRvR3JpZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTJEO0FBQ0g7QUFDWDtBQUVhO0FBQ1Q7QUFDTjtBQUNEO0FBQ007QUFTekMsTUFBTVcsWUFBc0M7UUFBQyxFQUNsREMsS0FBSyxFQUNMQyxZQUFZLEtBQUssRUFDakJDLFdBQVcsRUFDWEMsWUFBWSxFQUFFLEVBQ2Y7O0lBQ0MsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUUsR0FBR2QseURBQVFBO0lBQ2pFLE1BQU0sQ0FBQ2UsZ0JBQWdCQyxrQkFBa0IsR0FBR3BCLCtDQUFRQSxDQUFDO1FBQUVxQixPQUFPO1FBQUdDLFFBQVE7SUFBRTtJQUMzRSxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR3hCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ3lCLGFBQWFDLGVBQWUsR0FBRzFCLCtDQUFRQSxDQUFzQztJQUNwRixNQUFNMkIsVUFBVXpCLDZDQUFNQSxDQUFpQjtJQUN2QyxNQUFNLENBQUMwQixTQUFTQyxXQUFXLEdBQUc3QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUM4QixrQkFBa0JDLG9CQUFvQixHQUFHL0IsK0NBQVFBLENBQUM7SUFDekQsTUFBTSxDQUFDZ0MsWUFBWUMsY0FBYyxHQUFHakMsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDa0MsZ0JBQWdCQyxrQkFBa0IsR0FBR25DLCtDQUFRQSxDQUErQixFQUFFO0lBRXJGLGdEQUFnRDtJQUNoREMsZ0RBQVNBLENBQUM7UUFDUjRCLFdBQVc7UUFFWCxNQUFNTyxzQkFBc0I7WUFDMUIsSUFBSVQsUUFBUVUsT0FBTyxFQUFFO2dCQUNuQixNQUFNQyxPQUFPWCxRQUFRVSxPQUFPLENBQUNFLHFCQUFxQjtnQkFDbERuQixrQkFBa0I7b0JBQUVDLE9BQU9pQixLQUFLakIsS0FBSztvQkFBRUMsUUFB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RUYsT0FBTztvQ0FBSTtvQ0FDdkJySixXQUFXLG9CQUlWLE9BSEMwRyxvQkFDSSw2QkFDQTs4Q0FHTEEsa0NBQ0MsOERBQUNsSCxzRkFBSUE7d0NBQUN1RCxNQUFNOzs7OztrRUFFWiw4REFBQ3RELHNGQUFLQTt3Q0FBQ3NELE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7MkJBaENkLFFBQWVRLE9BQVBDLEtBQUksS0FBTyxPQUFKRDs7Ozs7b0JBc0MxQjs7Ozs7Ozs7Ozs7OztBQU1aLEVBQUU7R0F6ZVczRDs7UUFNOENOLHFEQUFRQTs7O0tBTnRETTtBQTJlYiwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9CZW50b0dyaWQudHN4PzRjOGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbW90aW9uLCBBbmltYXRlUHJlc2VuY2UgfSBmcm9tICdmcmFtZXItbW90aW9uJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnLi4vc3RvcmUvdXNlU3RvcmUnO1xuaW1wb3J0IHsgQmVudG9DYXJkIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgQmVudG9DYXJkQ29tcG9uZW50IH0gZnJvbSAnLi9CZW50b0NhcmRDb21wb25lbnQnO1xuaW1wb3J0IHsgUGx1cywgQ3Jvd24sIE1vdmUgfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xuaW1wb3J0IEdyaWRMYXlvdXQgZnJvbSAncmVhY3QtZ3JpZC1sYXlvdXQnO1xuaW1wb3J0ICdyZWFjdC1ncmlkLWxheW91dC9jc3Mvc3R5bGVzLmNzcyc7XG5pbXBvcnQgeyBSZXNpemFibGVDYXJkIH0gZnJvbSAnLi9SZXNpemFibGVDYXJkJztcblxuaW50ZXJmYWNlIEJlbnRvR3JpZFByb3BzIHtcbiAgY2FyZHM6IEJlbnRvQ2FyZFtdO1xuICBpc1ByZXZpZXc/OiBib29sZWFuO1xuICBvbkNhcmRDbGljaz86IChjYXJkSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgQmVudG9HcmlkOiBSZWFjdC5GQzxCZW50b0dyaWRQcm9wcz4gPSAoe1xuICBjYXJkcyxcbiAgaXNQcmV2aWV3ID0gZmFsc2UsXG4gIG9uQ2FyZENsaWNrLFxuICBjbGFzc05hbWUgPSAnJ1xufSkgPT4ge1xuICBjb25zdCB7IGN1cnJlbnRMYXlvdXQsIHVwZGF0ZUNhcmQsIGFkZENhcmQsIHVzZXJQbGFuIH0gPSB1c2VTdG9yZSgpO1xuICBjb25zdCBbZ3JpZERpbWVuc2lvbnMsIHNldEdyaWREaW1lbnNpb25zXSA9IHVzZVN0YXRlKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgY29uc3QgW2NlbGxTaXplLCBzZXRDZWxsU2l6ZV0gPSB1c2VTdGF0ZSgxMDApO1xuICBjb25zdCBbaG92ZXJlZENlbGwsIHNldEhvdmVyZWRDZWxsXSA9IHVzZVN0YXRlPHsgcm93OiBudW1iZXI7IGNvbDogbnVtYmVyIH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgZ3JpZFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzTGF5b3V0Q2hhbmdpbmcsIHNldElzTGF5b3V0Q2hhbmdpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYWRkaW5nQ2FyZCwgc2V0QWRkaW5nQ2FyZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlbXB0eUdyaWRDZWxscywgc2V0RW1wdHlHcmlkQ2VsbHNdID0gdXNlU3RhdGU8e3JvdzogbnVtYmVyLCBjb2w6IG51bWJlcn1bXT4oW10pO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGdyaWQgZGltZW5zaW9ucyBvbiBtb3VudCBhbmQgcmVzaXplXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICBcbiAgICBjb25zdCBjYWxjdWxhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKGdyaWRSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCByZWN0ID0gZ3JpZFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBzZXRHcmlkRGltZW5zaW9ucyh7IHdpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0IH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNlbGwgc2l6ZSBiYXNlZCBvbiBncmlkIHdpZHRoIGFuZCBjb2x1bW5zXG4gICAgICAgIGNvbnN0IGNvbHMgPSBnZXRHcmlkQ29sdW1ucygpO1xuICAgICAgICBjb25zdCBnYXBTaXplID0gZ2V0R2FwKCk7XG4gICAgICAgIGNvbnN0IHRvdGFsR2FwV2lkdGggPSBnYXBTaXplICogKGNvbHMgLSAxKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSByZWN0LndpZHRoIC0gdG90YWxHYXBXaWR0aDtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZENlbGxTaXplID0gTWF0aC5mbG9vcihhdmFpbGFibGVXaWR0aCAvIGNvbHMpO1xuICAgICAgICBzZXRDZWxsU2l6ZShjYWxjdWxhdGVkQ2VsbFNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgY2FsY3VsYXRlRGltZW5zaW9ucygpO1xuICAgIFxuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGNhbGN1bGF0ZURpbWVuc2lvbnMpO1xuICAgIGlmIChncmlkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZ3JpZFJlZi5jdXJyZW50KTtcbiAgICB9XG4gICAgXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNhbGN1bGF0ZURpbWVuc2lvbnMpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgY2FsY3VsYXRlRGltZW5zaW9ucyk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRMYXlvdXRdKTtcbiAgXG4gIC8vIERldGVybWluZSBudW1iZXIgb2YgY29sdW1ucyBiYXNlZCBvbiBsYXlvdXRcbiAgY29uc3QgZ2V0R3JpZENvbHVtbnMgPSAoKSA9PiB7XG4gICAgc3dpdGNoIChjdXJyZW50TGF5b3V0KSB7XG4gICAgICBjYXNlICdtb2JpbGUnOiByZXR1cm4gMjtcbiAgICAgIGNhc2UgJ3RhYmxldCc6IHJldHVybiA0O1xuICAgICAgY2FzZSAnZGVza3RvcCc6IGRlZmF1bHQ6IHJldHVybiAxMjtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBEZXRlcm1pbmUgbnVtYmVyIG9mIHJvd3MgYmFzZWQgb24gbGF5b3V0IC0gRklYRUQgVE8gNiBST1dTIE1BWFxuICBjb25zdCBnZXRHcmlkUm93cyA9ICgpID0+IHtcbiAgICBzd2l0Y2ggKGN1cnJlbnRMYXlvdXQpIHtcbiAgICAgIGNhc2UgJ21vYmlsZSc6IHJldHVybiA2O1xuICAgICAgY2FzZSAndGFibGV0JzogcmV0dXJuIDY7XG4gICAgICBjYXNlICdkZXNrdG9wJzogZGVmYXVsdDogcmV0dXJuIDY7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRGV0ZXJtaW5lIGdhcCBiYXNlZCBvbiBsYXlvdXRcbiAgY29uc3QgZ2V0R2FwID0gKCkgPT4ge1xuICAgIHN3aXRjaCAoY3VycmVudExheW91dCkge1xuICAgICAgY2FzZSAnbW9iaWxlJzogcmV0dXJuIDg7XG4gICAgICBjYXNlICd0YWJsZXQnOiByZXR1cm4gMTI7XG4gICAgICBjYXNlICdkZXNrdG9wJzogZGVmYXVsdDogcmV0dXJuIDE2O1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIENvbnZlcnQgY2FyZCBzaXplIHRvIGNvbHVtbiBhbmQgcm93IHNwYW4gLSBGSVhFRCBMT0dJQ1xuICBjb25zdCBnZXRDYXJkU2l6ZSA9IChjYXJkOiBCZW50b0NhcmQpID0+IHtcbiAgICBjb25zdCBbY29sU3Bhbiwgcm93U3Bhbl0gPSBjYXJkLnNpemUuc3BsaXQoJ3gnKS5tYXAoTnVtYmVyKTtcbiAgICBcbiAgICAvLyBBZGFwdCBzaXplIGJhc2VkIG9uIGxheW91dFxuICAgIGlmIChjdXJyZW50TGF5b3V0ID09PSAnbW9iaWxlJykge1xuICAgICAgLy8gT24gbW9iaWxlLCBsaW1pdCB0byAyIGNvbHVtbnMgbWF4XG4gICAgICBjb25zdCBhZGFwdGVkQ29sU3BhbiA9IE1hdGgubWluKGNvbFNwYW4sIDIpO1xuICAgICAgcmV0dXJuIHsgY29sU3BhbjogYWRhcHRlZENvbFNwYW4sIHJvd1NwYW4gfTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRMYXlvdXQgPT09ICd0YWJsZXQnKSB7XG4gICAgICAvLyBPbiB0YWJsZXQsIGxpbWl0IHRvIDQgY29sdW1ucyBtYXhcbiAgICAgIGNvbnN0IGFkYXB0ZWRDb2xTcGFuID0gTWF0aC5taW4oY29sU3BhbiwgNCk7XG4gICAgICByZXR1cm4geyBjb2xTcGFuOiBhZGFwdGVkQ29sU3Bhbiwgcm93U3BhbiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDT1JSRUNUSU9OOiBPbiBkZXNrdG9wLCB1c2UgdGhlIGFjdHVhbCBzaXplIGZyb20gY2FyZC5zaXplLCBkb24ndCBtb2RpZnkgaXRcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBjb2xTcGFuOiBNYXRoLm1pbihjb2xTcGFuLCAxMiksIFxuICAgICAgICByb3dTcGFuOiBNYXRoLm1pbihyb3dTcGFuLCA2KSBcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBcbiAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnNcbiAgY29uc3QgaGFzQ29sbGlzaW9uID0gKGNhcmRJZDogc3RyaW5nLCBjb2w6IG51bWJlciwgcm93OiBudW1iZXIsIGNvbFNwYW46IG51bWJlciwgcm93U3BhbjogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgLy8gQ2hlY2sgZ3JpZCBib3VuZGFyaWVzXG4gICAgaWYgKGNvbCA8IDAgfHwgcm93IDwgMCB8fCBjb2wgKyBjb2xTcGFuID4gZ2V0R3JpZENvbHVtbnMoKSB8fCByb3cgKyByb3dTcGFuID4gZ2V0R3JpZFJvd3MoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGZvciAoY29uc3QgY2FyZCBvZiBjYXJkcykge1xuICAgICAgaWYgKGNhcmQuaWQgPT09IGNhcmRJZCB8fCAhY2FyZC5ncmlkUG9zaXRpb24pIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCB7IGNvbFNwYW46IGNhcmRDb2xTcGFuLCByb3dTcGFuOiBjYXJkUm93U3BhbiB9ID0gZ2V0Q2FyZFNpemUoY2FyZCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHJlY3RhbmdsZXMgb3ZlcmxhcFxuICAgICAgY29uc3Qgb3ZlcmxhcCA9ICEoXG4gICAgICAgIGNvbCA+PSBjYXJkLmdyaWRQb3NpdGlvbi5jb2wgKyBjYXJkQ29sU3BhbiB8fCAvLyBSaWdodFxuICAgICAgICBjb2wgKyBjb2xTcGFuIDw9IGNhcmQuZ3JpZFBvc2l0aW9uLmNvbCB8fCAgICAgLy8gTGVmdFxuICAgICAgICByb3cgPj0gY2FyZC5ncmlkUG9zaXRpb24ucm93ICsgY2FyZFJvd1NwYW4gfHwgLy8gQm90dG9tXG4gICAgICAgIHJvdyArIHJvd1NwYW4gPD0gY2FyZC5ncmlkUG9zaXRpb24ucm93ICAgICAgICAvLyBUb3BcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChvdmVybGFwKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIEludGVsbGlnZW50IHJlc2l6ZSBmdW5jdGlvblxuICBjb25zdCBoYW5kbGVJbnRlbGxpZ2VudFJlc2l6ZSA9IChjYXJkSWQ6IHN0cmluZywgbmV3Q29sczogbnVtYmVyLCBuZXdSb3dzOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBjYXJkID0gY2FyZHMuZmluZChjID0+IGMuaWQgPT09IGNhcmRJZCk7XG4gICAgaWYgKCFjYXJkIHx8ICFjYXJkLmdyaWRQb3NpdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGNvbnN0IGN1cnJlbnRDb2wgPSBjYXJkLmdyaWRQb3NpdGlvbi5jb2w7XG4gICAgY29uc3QgY3VycmVudFJvdyA9IGNhcmQuZ3JpZFBvc2l0aW9uLnJvdztcbiAgICBcbiAgICAvLyBDaGVjayBncmlkIGxpbWl0c1xuICAgIGlmIChjdXJyZW50Q29sICsgbmV3Q29scyA+IGdldEdyaWRDb2x1bW5zKCkgfHwgY3VycmVudFJvdyArIG5ld1Jvd3MgPiBnZXRHcmlkUm93cygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zXG4gICAgaWYgKGhhc0NvbGxpc2lvbihjYXJkSWQsIGN1cnJlbnRDb2wsIGN1cnJlbnRSb3csIG5ld0NvbHMsIG5ld1Jvd3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgLy8gQ29udmVydCBjYXJkcyB0byBSZWFjdC1HcmlkLUxheW91dCBmb3JtYXRcbiAgY29uc3QgZ2V0TGF5b3V0SXRlbXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGNhcmRzLm1hcChjYXJkID0+IHtcbiAgICAgIGlmICghY2FyZC5ncmlkUG9zaXRpb24pIHJldHVybiBudWxsO1xuICAgICAgXG4gICAgICBjb25zdCB7IGNvbFNwYW4sIHJvd1NwYW4gfSA9IGdldENhcmRTaXplKGNhcmQpO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpOiBjYXJkLmlkLFxuICAgICAgICB4OiBjYXJkLmdyaWRQb3NpdGlvbi5jb2wsXG4gICAgICAgIHk6IGNhcmQuZ3JpZFBvc2l0aW9uLnJvdyxcbiAgICAgICAgdzogY29sU3BhbixcbiAgICAgICAgaDogcm93U3BhbixcbiAgICAgICAgc3RhdGljOiBpc1ByZXZpZXcsXG4gICAgICAgIG1heFc6IGdldEdyaWRDb2x1bW5zKCksXG4gICAgICAgIG1heEg6IGdldEdyaWRSb3dzKClcbiAgICAgIH07XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pIGFzIEdyaWRMYXlvdXQuTGF5b3V0W107XG4gIH07XG4gIFxuICAvLyBIYW5kbGUgbGF5b3V0IGNoYW5nZSBmcm9tIFJlYWN0LUdyaWQtTGF5b3V0XG4gIGNvbnN0IGhhbmRsZUxheW91dENoYW5nZSA9IChsYXlvdXQ6IEdyaWRMYXlvdXQuTGF5b3V0W10pID0+IHtcbiAgICBpZiAoaXNQcmV2aWV3IHx8IGlzTGF5b3V0Q2hhbmdpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBTZXQgYSBmbGFnIHRvIHByZXZlbnQgbXVsdGlwbGUgdXBkYXRlc1xuICAgIHNldElzTGF5b3V0Q2hhbmdpbmcodHJ1ZSk7XG4gICAgXG4gICAgLy8gUHJvY2VzcyBsYXlvdXQgY2hhbmdlcyBvbmUgYnkgb25lIHRvIHByZXZlbnQgY2FzY2FkaW5nIHVwZGF0ZXNcbiAgICBjb25zdCB1cGRhdGVzID0gbGF5b3V0Lm1hcChpdGVtID0+IHtcbiAgICAgIGNvbnN0IGNhcmQgPSBjYXJkcy5maW5kKGMgPT4gYy5pZCA9PT0gaXRlbS5pKTtcbiAgICAgIGlmIChjYXJkICYmIGNhcmQuZ3JpZFBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChjYXJkLmdyaWRQb3NpdGlvbi5jb2wgIT09IGl0ZW0ueCB8fCBjYXJkLmdyaWRQb3NpdGlvbi5yb3cgIT09IGl0ZW0ueSkge1xuICAgICAgICAgIHJldHVybiB7IGlkOiBjYXJkLmlkLCB4OiBpdGVtLngsIHk6IGl0ZW0ueSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgXG4gICAgLy8gQXBwbHkgdXBkYXRlcyBzZXF1ZW50aWFsbHlcbiAgICBpZiAodXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgY2FyZCB0aGF0IHdhcyBhY3R1YWxseSBtb3ZlZCBieSB0aGUgdXNlclxuICAgICAgY29uc3QgdXBkYXRlID0gdXBkYXRlc1swXTtcbiAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgdXBkYXRlQ2FyZCh1cGRhdGUuaWQsIHtcbiAgICAgICAgICBncmlkUG9zaXRpb246IHsgY29sOiB1cGRhdGUueCwgcm93OiB1cGRhdGUueSB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZXNldCB0aGUgZmxhZyBhZnRlciBhIHNob3J0IGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRJc0xheW91dENoYW5naW5nKGZhbHNlKTtcbiAgICB9LCAxMDApO1xuICB9O1xuXG4gIC8vIENoZWNrIGlmIGEgY2VsbCBpcyBmcmVlIChub3Qgb2NjdXBpZWQgYnkgYW55IGNhcmQpXG4gIGNvbnN0IGlzQ2VsbEZyZWUgPSAocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHJvdyA+PSBnZXRHcmlkUm93cygpIHx8IGNvbCA+PSBnZXRHcmlkQ29sdW1ucygpKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYW55IGNhcmQgb2NjdXBpZXMgdGhpcyBjZWxsXG4gICAgZm9yIChjb25zdCBjYXJkIG9mIGNhcmRzKSB7XG4gICAgICBpZiAoIWNhcmQuZ3JpZFBvc2l0aW9uKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBjb2xTcGFuLCByb3dTcGFuIH0gPSBnZXRDYXJkU2l6ZShjYXJkKTtcbiAgICAgIGNvbnN0IGNhcmRTdGFydENvbCA9IGNhcmQuZ3JpZFBvc2l0aW9uLmNvbDtcbiAgICAgIGNvbnN0IGNhcmRFbmRDb2wgPSBjYXJkU3RhcnRDb2wgKyBjb2xTcGFuIC0gMTtcbiAgICAgIGNvbnN0IGNhcmRTdGFydFJvdyA9IGNhcmQuZ3JpZFBvc2l0aW9uLnJvdztcbiAgICAgIGNvbnN0IGNhcmRFbmRSb3cgPSBjYXJkU3RhcnRSb3cgKyByb3dTcGFuIC0gMTtcbiAgICAgIFxuICAgICAgaWYgKGNvbCA+PSBjYXJkU3RhcnRDb2wgJiYgY29sIDw9IGNhcmRFbmRDb2wgJiYgXG4gICAgICAgICAgcm93ID49IGNhcmRTdGFydFJvdyAmJiByb3cgPD0gY2FyZEVuZFJvdykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBjYXJkIGF0IGEgc3BlY2lmaWMgcG9zaXRpb24gLSBERUJVR1xuICBjb25zdCBoYW5kbGVBZGRDYXJkID0gYXN5bmMgKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcikgPT4ge1xuICAvLyBERUJVRzogQWZmaWNoZXIgbGVzIHZhbGV1cnMgYWN0dWVsbGVzXG4gIGNvbnNvbGUubG9nKCfwn5SNIERFQlVHIGhhbmRsZUFkZENhcmQ6Jyk7XG4gIGNvbnNvbGUubG9nKCdjdXJyZW50TGF5b3V0OicsIGN1cnJlbnRMYXlvdXQpO1xuICBjb25zb2xlLmxvZygnZ2V0R3JpZENvbHVtbnMoKTonLCBnZXRHcmlkQ29sdW1ucygpKTtcbiAgY29uc29sZS5sb2coJ1Bvc2l0aW9uIGRlbWFuZMOpZTonLCB7IHJvdywgY29sIH0pO1xuICBcbiAgLy8gQ2hlY2sgaWYgdGhlIGNlbGwgaXMgZnJlZVxuICBpZiAoIWlzQ2VsbEZyZWUocm93LCBjb2wpIHx8IGFkZGluZ0NhcmQpIHJldHVybjtcbiAgXG4gIHNldEFkZGluZ0NhcmQodHJ1ZSk7XG4gIFxuICB0cnkge1xuICAgICAgLy8gQ09SUkVDVElPTjogRm9yY2UgbGEgYm9ubmUgdGFpbGxlIHBvdXIgZGVza3RvcFxuICAgICAgbGV0IGNhcmRTaXplOiBzdHJpbmc7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRMYXlvdXQpIHtcbiAgICAgICAgY2FzZSAnbW9iaWxlJzpcbiAgICAgICAgICBjYXJkU2l6ZSA9ICcxeDEnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YWJsZXQnOlxuICAgICAgICAgIGNhcmRTaXplID0gJzF4MSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rlc2t0b3AnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhcmRTaXplID0gJzJ4Mic7IC8vIEZvcmNlciAyeDIgcG91ciBkZXNrdG9wXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG5ld0NhcmQgPSB7XG4gICAgICAgIHRpdGxlOiAnTm91dmVsbGUgQ2FydGUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NsaXF1ZXogcG91ciDDqWRpdGVyIGNldHRlIGNhcnRlJyxcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzYzNjZmMScsXG4gICAgICAgIHRleHRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICBzaXplOiBjYXJkU2l6ZSBhcyBhbnksIC8vIEZvcmNlIGxlIHR5cGVcbiAgICAgICAgZ3JpZFBvc2l0aW9uOiB7IGNvbCwgcm93IH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkZENhcmQobmV3Q2FyZCk7XG4gICAgICBcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgYWxlcnQocmVzdWx0LmVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9wZW4gZWRpdG9yIGZvciB0aGUgbmV3IGNhcmRcbiAgICAgICAgb25DYXJkQ2xpY2sgJiYgb25DYXJkQ2xpY2socmVzdWx0LmNhcmRJZCB8fCAnJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhZGRpbmcgY2FyZDpcIiwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRBZGRpbmdDYXJkKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hlY2sgcGxhbiBsaW1pdHNcbiAgY29uc3QgY2FuQWRkTW9yZUNhcmRzID0gKCkgPT4ge1xuICAgIGlmICh1c2VyUGxhbiA9PT0gJ2ZyZWUnKSByZXR1cm4gY2FyZHMubGVuZ3RoIDwgMztcbiAgICBpZiAodXNlclBsYW4gPT09ICdzdGFydGVyJykgcmV0dXJuIGNhcmRzLmxlbmd0aCA8IDI1O1xuICAgIHJldHVybiB0cnVlOyAvLyBQcm8gcGxhbiA9IHVubGltaXRlZFxuICB9O1xuXG4gIC8vIENhbGN1bGF0ZSBncmlkIGhlaWdodCBiYXNlZCBvbiBjb250ZW50XG4gIGNvbnN0IGdyaWRIZWlnaHQgPSBnZXRHcmlkUm93cygpICogY2VsbFNpemUgKyAoZ2V0R3JpZFJvd3MoKSAtIDEpICogZ2V0R2FwKCk7XG5cbiAgLy8gQ2FsY3VsYXRlIGFsbCBlbXB0eSBjZWxscyBmb3IgdGhlIGdyaWQgLSBGSVhFRFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1heENvbHMgPSBnZXRHcmlkQ29sdW1ucygpO1xuICAgIGNvbnN0IG1heFJvd3MgPSBnZXRHcmlkUm93cygpO1xuICAgIGNvbnN0IGVtcHR5Q2VsbHM6IHtyb3c6IG51bWJlciwgY29sOiBudW1iZXJ9W10gPSBbXTtcbiAgICBcbiAgICAvLyBDaGVjayBlYWNoIGNlbGwgaW4gdGhlIGdyaWRcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXhSb3dzOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgbWF4Q29sczsgY29sKyspIHtcbiAgICAgICAgaWYgKGlzQ2VsbEZyZWUocm93LCBjb2wpKSB7XG4gICAgICAgICAgLy8gQ09SUkVDVElPTjogTG9naXF1ZSBwbHVzIHNpbXBsZSBldCBjb2jDqXJlbnRlXG4gICAgICAgICAgaWYgKGN1cnJlbnRMYXlvdXQgPT09ICdkZXNrdG9wJykge1xuICAgICAgICAgICAgLy8gUG91ciBkZXNrdG9wLCB2w6lyaWZpZXIgbCdlc3BhY2UgcG91ciB1bmUgY2FydGUgMngyXG4gICAgICAgICAgICBsZXQgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBWw6lyaWZpZXIgc2kgb24gYSBhc3NleiBkJ2VzcGFjZSAoMngyKVxuICAgICAgICAgICAgaWYgKGNvbCArIDIgPiBtYXhDb2xzIHx8IHJvdyArIDIgPiBtYXhSb3dzKSB7XG4gICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBWw6lyaWZpZXIgcXVlIHRvdXRlcyBsZXMgY2VsbHVsZXMgbsOpY2Vzc2FpcmVzIHNvbnQgbGlicmVzXG4gICAgICAgICAgICAgIGZvciAobGV0IHIgPSByb3c7IHIgPCByb3cgKyAyOyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY29sOyBjIDwgY29sICsgMjsgYysrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzQ2VsbEZyZWUociwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzU3BhY2UpIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChoYXNTcGFjZSkge1xuICAgICAgICAgICAgICBlbXB0eUNlbGxzLnB1c2goeyByb3csIGNvbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUG91ciBtb2JpbGUgZXQgdGFibGV0LCBham91dGVyIGRpcmVjdGVtZW50XG4gICAgICAgICAgICBlbXB0eUNlbGxzLnB1c2goeyByb3csIGNvbCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2V0RW1wdHlHcmlkQ2VsbHMoZW1wdHlDZWxscyk7XG4gIH0sIFtjYXJkcywgY3VycmVudExheW91dCwgbW91bnRlZF0pO1xuICBcbiAgLy8gVXNlIGZhbGxiYWNrIHZhbHVlcyB0byBlbnN1cmUgR3JpZExheW91dCBhbHdheXMgcmVjZWl2ZXMgdmFsaWQgcHJvcHNcbiAgY29uc3Qgc2FmZUdyaWRXaWR0aCA9IGdyaWREaW1lbnNpb25zLndpZHRoIHx8IDE7XG4gIGNvbnN0IHNhZmVDZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDE7XG5cbiAgaWYgKCFtb3VudGVkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtOTYgYmctZ3JheS0xMDAgcm91bmRlZC1sZyBhbmltYXRlLXB1bHNlIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMFwiPkxvYWRpbmcgZ3JpZC4uLjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuICBcbiAgcmV0dXJuIChcbiAgICA8ZGl2IFxuICAgICAgcmVmPXtncmlkUmVmfVxuICAgICAgY2xhc3NOYW1lPXtgcmVsYXRpdmUgdG91Y2gtbm9uZSAke2NsYXNzTmFtZX1gfVxuICAgICAgc3R5bGU9e3sgXG4gICAgICAgIGhlaWdodDogZ3JpZEhlaWdodCxcbiAgICAgICAgbWluSGVpZ2h0OiAnMzAwcHgnLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfX1cbiAgICA+XG4gICAgICB7aXNQcmV2aWV3ID8gKFxuICAgICAgICAvLyBQcmV2aWV3IG1vZGUgLSBzdGF0aWMgZ3JpZFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IGByZXBlYXQoJHtnZXRHcmlkQ29sdW1ucygpfSwgMWZyKWAsXG4gICAgICAgICAgICBncmlkVGVtcGxhdGVSb3dzOiBgcmVwZWF0KCR7Z2V0R3JpZFJvd3MoKX0sIDFmcilgLFxuICAgICAgICAgICAgZ2FwOiBgJHtnZXRHYXAoKX1weGAsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAge2NhcmRzLm1hcCgoY2FyZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjYXJkLmdyaWRQb3NpdGlvbikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdldCBncmlkIHNwYW5cbiAgICAgICAgICAgIGNvbnN0IHsgY29sU3Bhbiwgcm93U3BhbiB9ID0gZ2V0Q2FyZFNpemUoY2FyZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAga2V5PXtjYXJkLmlkfVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBncmlkQ29sdW1uOiBgJHtjYXJkLmdyaWRQb3NpdGlvbi5jb2wgKyAxfSAvIHNwYW4gJHtjb2xTcGFufWAsXG4gICAgICAgICAgICAgICAgICBncmlkUm93OiBgJHtjYXJkLmdyaWRQb3NpdGlvbi5yb3cgKyAxfSAvIHNwYW4gJHtyb3dTcGFufWAsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8QmVudG9DYXJkQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICBjYXJkPXtjYXJkfVxuICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3TW9kZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IChcbiAgICAgICAgPD5cbiAgICAgICAgICA8R3JpZExheW91dFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibGF5b3V0XCJcbiAgICAgICAgICAgIGxheW91dD17Z2V0TGF5b3V0SXRlbXMoKX1cbiAgICAgICAgICAgIGNvbHM9e2dldEdyaWRDb2x1bW5zKCl9XG4gICAgICAgICAgICByb3dIZWlnaHQ9e3NhZmVDZWxsU2l6ZX1cbiAgICAgICAgICAgIHdpZHRoPXtzYWZlR3JpZFdpZHRofVxuICAgICAgICAgICAgbWFyZ2luPXtbZ2V0R2FwKCksIGdldEdhcCgpXX1cbiAgICAgICAgICAgIGNvbnRhaW5lclBhZGRpbmc9e1swLCAwXX1cbiAgICAgICAgICAgIG9uTGF5b3V0Q2hhbmdlPXtoYW5kbGVMYXlvdXRDaGFuZ2V9XG4gICAgICAgICAgICBpc0RyYWdnYWJsZT17IWlzUHJldmlldyAmJiBjdXJyZW50TGF5b3V0ID09PSAnZGVza3RvcCd9XG4gICAgICAgICAgICBpc1Jlc2l6YWJsZT17ZmFsc2V9ICAvLyBEaXNhYmxlIFJHTCdzIGJ1aWx0LWluIHJlc2l6ZVxuICAgICAgICAgICAgY29tcGFjdFR5cGU9e251bGx9XG4gICAgICAgICAgICBwcmV2ZW50Q29sbGlzaW9uPXt0cnVlfVxuICAgICAgICAgICAgdXNlQ1NTVHJhbnNmb3Jtcz17dHJ1ZX1cbiAgICAgICAgICAgIGRyYWdnYWJsZUhhbmRsZT1cIi5kcmFnLWhhbmRsZVwiXG4gICAgICAgICAgICBtYXhSb3dzPXtnZXRHcmlkUm93cygpfVxuICAgICAgICAgICAgcmVzaXplSGFuZGxlcz17W119ICAvLyBSZW1vdmUgYWxsIFJHTCByZXNpemUgaGFuZGxlc1xuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjYXJkcy5tYXAoKGNhcmQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFjYXJkLmdyaWRQb3NpdGlvbikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXYga2V5PXtjYXJkLmlkfSBjbGFzc05hbWU9XCJoLWZ1bGwgdy1mdWxsXCI+XG4gICAgICAgICAgICAgICAgICA8UmVzaXphYmxlQ2FyZFxuICAgICAgICAgICAgICAgICAgICBjYXJkPXtjYXJkfVxuICAgICAgICAgICAgICAgICAgICBjZWxsU2l6ZT17c2FmZUNlbGxTaXplfVxuICAgICAgICAgICAgICAgICAgICBnYXA9e2dldEdhcCgpfVxuICAgICAgICAgICAgICAgICAgICBtYXhDb2xzPXtnZXRHcmlkQ29sdW1ucygpfVxuICAgICAgICAgICAgICAgICAgICBtYXhSb3dzPXtnZXRHcmlkUm93cygpfVxuICAgICAgICAgICAgICAgICAgICBvbkludGVsbGlnZW50UmVzaXplPXtoYW5kbGVJbnRlbGxpZ2VudFJlc2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgb25FZGl0PXsoKSA9PiBvbkNhcmRDbGljayAmJiBvbkNhcmRDbGljayhjYXJkLmlkKX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L0dyaWRMYXlvdXQ+XG4gICAgICAgICAgXG4gICAgICAgICAgey8qIEVtcHR5IGNlbGwgZ3JpZCBmb3IgYWRkaW5nIG5ldyBjYXJkcyAqL31cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIHBvaW50ZXItZXZlbnRzLW5vbmVcIlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBgcmVwZWF0KCR7Z2V0R3JpZENvbHVtbnMoKX0sIDFmcilgLFxuICAgICAgICAgICAgICBncmlkVGVtcGxhdGVSb3dzOiBgcmVwZWF0KCR7Z2V0R3JpZFJvd3MoKX0sIDFmcilgLFxuICAgICAgICAgICAgICBnYXA6IGAke2dldEdhcCgpfXB4YCxcbiAgICAgICAgICAgICAgekluZGV4OiA1XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtlbXB0eUdyaWRDZWxscy5tYXAoKHsgcm93LCBjb2wgfSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpc0hvdmVyZWQgPSBob3ZlcmVkQ2VsbD8ucm93ID09PSByb3cgJiYgaG92ZXJlZENlbGw/LmNvbCA9PT0gY29sO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBrZXk9e2BjZWxsLSR7cm93fS0ke2NvbH1gfVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogY29sICsgMSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFJvdzogcm93ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjdXJzb3ItcG9pbnRlciBwb2ludGVyLWV2ZW50cy1hdXRvXCJcbiAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4gc2V0SG92ZXJlZENlbGwoeyByb3csIGNvbCB9KX1cbiAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0SG92ZXJlZENlbGwobnVsbCl9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVBZGRDYXJkKHJvdywgY29sKX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7LyogRW1wdHkgY2VsbCB3aXRoIGhvdmVyIGVmZmVjdCAqL31cbiAgICAgICAgICAgICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMCB9fVxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlPXt7IFxuICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzSG92ZXJlZCA/IDEgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBpc0hvdmVyZWQgPyAxIDogMC44XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgcm91bmRlZC1sZyBib3JkZXItMiBib3JkZXItZGFzaGVkIGJvcmRlci1pbmRpZ28tNTAwLzQwIGJnLWluZGlnby01MDAvMTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlSG92ZXI9e3sgc2NhbGU6IDEuMSB9fVxuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlVGFwPXt7IHNjYWxlOiAwLjkgfX1cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BwLTIgcm91bmRlZC1mdWxsICR7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5BZGRNb3JlQ2FyZHMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1pbmRpZ28tNTAwIHRleHQtd2hpdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLXJlZC01MDAgdGV4dC13aGl0ZSdcbiAgICAgICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIHtjYW5BZGRNb3JlQ2FyZHMoKSA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxQbHVzIHNpemU9ezE2fSAvPlxuICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q3Jvd24gc2l6ZT17MTZ9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgICAgICAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJlbnRvR3JpZDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsIm1vdGlvbiIsInVzZVN0b3JlIiwiQmVudG9DYXJkQ29tcG9uZW50IiwiUGx1cyIsIkNyb3duIiwiR3JpZExheW91dCIsIlJlc2l6YWJsZUNhcmQiLCJCZW50b0dyaWQiLCJjYXJkcyIsImlzUHJldmlldyIsIm9uQ2FyZENsaWNrIiwiY2xhc3NOYW1lIiwiY3VycmVudExheW91dCIsInVwZGF0ZUNhcmQiLCJhZGRDYXJkIiwidXNlclBsYW4iLCJncmlkRGltZW5zaW9ucyIsInNldEdyaWREaW1lbnNpb25zIiwid2lkdGgiLCJoZWlnaHQiLCJjZWxsU2l6ZSIsInNldENlbGxTaXplIiwiaG92ZXJlZENlbGwiLCJzZXRIb3ZlcmVkQ2VsbCIsImdyaWRSZWYiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsImlzTGF5b3V0Q2hhbmdpbmciLCJzZXRJc0xheW91dENoYW5naW5nIiwiYWRkaW5nQ2FyZCIsInNldEFkZGluZ0NhcmQiLCJlbXB0eUdyaWRDZWxscyIsInNldEVtcHR5R3JpZENlbGxzIiwiY2FsY3VsYXRlRGltZW5zaW9ucyIsImN1cnJlbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY29scyIsImdldEdyaWRDb2x1bW5zIiwiZ2FwU2l6ZSIsImdldEdhcCIsInRvdGFsR2FwV2lkdGgiLCJhdmFpbGFibGVXaWR0aCIsImNhbGN1bGF0ZWRDZWxsU2l6ZSIsIk1hdGgiLCJmbG9vciIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0R3JpZFJvd3MiLCJnZXRDYXJkU2l6ZSIsImNhcmQiLCJjb2xTcGFuIiwicm93U3BhbiIsInNpemUiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImFkYXB0ZWRDb2xTcGFuIiwibWluIiwiaGFzQ29sbGlzaW9uIiwiY2FyZElkIiwiY29sIiwicm93IiwiaWQiLCJncmlkUG9zaXRpb24iLCJjYXJkQ29sU3BhbiIsImNhcmRSb3dTcGFuIiwib3ZlcmxhcCIsImhhbmRsZUludGVsbGlnZW50UmVzaXplIiwibmV3Q29scyIsIm5ld1Jvd3MiLCJmaW5kIiwiYyIsImN1cnJlbnRDb2wiLCJjdXJyZW50Um93IiwiZ2V0TGF5b3V0SXRlbXMiLCJpIiwieCIsInkiLCJ3IiwiaCIsInN0YXRpYyIsIm1heFciLCJtYXhIIiwiZmlsdGVyIiwiQm9vbGVhbiIsImhhbmRsZUxheW91dENoYW5nZSIsImxheW91dCIsInVwZGF0ZXMiLCJpdGVtIiwibGVuZ3RoIiwidXBkYXRlIiwic2V0VGltZW91dCIsImlzQ2VsbEZyZWUiLCJjYXJkU3RhcnRDb2wiLCJjYXJkRW5kQ29sIiwiY2FyZFN0YXJ0Um93IiwiY2FyZEVuZFJvdyIsImhhbmRsZUFkZENhcmQiLCJjb25zb2xlIiwibG9nIiwiY2FyZFNpemUiLCJuZXdDYXJkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInVybCIsImJhY2tncm91bmRDb2xvciIsInRleHRDb2xvciIsInJlc3VsdCIsInN1Y2Nlc3MiLCJhbGVydCIsImVycm9yIiwiY2FuQWRkTW9yZUNhcmRzIiwiZ3JpZEhlaWdodCIsIm1heENvbHMiLCJtYXhSb3dzIiwiZW1wdHlDZWxscyIsImhhc1NwYWNlIiwiciIsInB1c2giLCJzYWZlR3JpZFdpZHRoIiwic2FmZUNlbGxTaXplIiwiZGl2IiwicmVmIiwic3R5bGUiLCJtaW5IZWlnaHQiLCJwb3NpdGlvbiIsImRpc3BsYXkiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwiZ3JpZFRlbXBsYXRlUm93cyIsImdhcCIsImdyaWRDb2x1bW4iLCJncmlkUm93IiwiaXNQcmV2aWV3TW9kZSIsInJvd0hlaWdodCIsIm1hcmdpbiIsImNvbnRhaW5lclBhZGRpbmciLCJvbkxheW91dENoYW5nZSIsImlzRHJhZ2dhYmxlIiwiaXNSZXNpemFibGUiLCJjb21wYWN0VHlwZSIsInByZXZlbnRDb2xsaXNpb24iLCJ1c2VDU1NUcmFuc2Zvcm1zIiwiZHJhZ2dhYmxlSGFuZGxlIiwicmVzaXplSGFuZGxlcyIsIm9uSW50ZWxsaWdlbnRSZXNpemUiLCJvbkVkaXQiLCJ6SW5kZXgiLCJpc0hvdmVyZWQiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJvbkNsaWNrIiwiaW5pdGlhbCIsIm9wYWNpdHkiLCJhbmltYXRlIiwic2NhbGUiLCJ3aGlsZUhvdmVyIiwid2hpbGVUYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/BentoGrid.tsx\n"));

/***/ })

});
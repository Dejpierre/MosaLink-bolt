"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/BentoGrid.tsx":
/*!**************************************!*\
  !*** ./src/components/BentoGrid.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BentoGrid: function() { return /* binding */ BentoGrid; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/dom/motion.mjs\");\n/* harmony import */ var _store_useStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/useStore */ \"(app-pages-browser)/./src/store/useStore.ts\");\n/* harmony import */ var _BentoCardComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BentoCardComponent */ \"(app-pages-browser)/./src/components/BentoCardComponent.tsx\");\n/* harmony import */ var _barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Crown,Plus!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/plus.js\");\n/* harmony import */ var _barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Crown,Plus!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/crown.js\");\n/* harmony import */ var react_grid_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-grid-layout */ \"(app-pages-browser)/./node_modules/react-grid-layout/index.js\");\n/* harmony import */ var react_grid_layout__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_grid_layout__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_grid_layout_css_styles_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-grid-layout/css/styles.css */ \"(app-pages-browser)/./node_modules/react-grid-layout/css/styles.css\");\n/* harmony import */ var _ResizableCard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ResizableCard */ \"(app-pages-browser)/./src/components/ResizableCard.tsx\");\n/* __next_internal_client_entry_do_not_use__ BentoGrid,default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst BentoGrid = (param)=>{\n    let { cards, isPreview = false, onCardClick, className = \"\" } = param;\n    _s();\n    const { currentLayout, updateCard, addCard, userPlan } = (0,_store_useStore__WEBPACK_IMPORTED_MODULE_2__.useStore)();\n    const [gridDimensions, setGridDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [cellSize, setCellSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(100);\n    const [hoveredCell, setHoveredCell] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const gridRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLayoutChanging, setIsLayoutChanging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [addingCard, setAddingCard] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [emptyGridCells, setEmptyGridCells] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Calculate grid dimensions on mount and resize\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setMounted(true);\n        const calculateDimensions = ()=>{\n            if (gridRef.current) {\n                const rect = gridRef.current.getBoundingClientRect();\n                setGridDimensions({\n                    width: rect.width,\n                    height: rect.height\n                });\n                // Calculate cell size based on grid width and columns\n                const cols = getGridColumns();\n                const gapSize = getGap();\n                const totalGapWidth = gapSize * (cols - 1);\n                const availableWidth = rect.width - totalGapWidth;\n                const calculatedCellSize = Math.floor(availableWidth / cols);\n                setCellSize(calculatedCellSize);\n            }\n        };\n        calculateDimensions();\n        const resizeObserver = new ResizeObserver(calculateDimensions);\n        if (gridRef.current) {\n            resizeObserver.observe(gridRef.current);\n        }\n        window.addEventListener(\"resize\", calculateDimensions);\n        return ()=>{\n            resizeObserver.disconnect();\n            window.removeEventListener(\"resize\", calculateDimensions);\n        };\n    }, [\n        currentLayout\n    ]);\n    // Determine number of columns based on layout\n    const getGridColumns = ()=>{\n        const cols = (()=>{\n            switch(currentLayout){\n                case \"mobile\":\n                    return 2;\n                case \"tablet\":\n                    return 4;\n                case \"desktop\":\n                default:\n                    return 12;\n            }\n        })();\n        return cols;\n    };\n    // Determine number of rows based on layout - FIXED TO 6 ROWS MAX\n    const getGridRows = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 6;\n            case \"tablet\":\n                return 6;\n            case \"desktop\":\n            default:\n                return 6;\n        }\n    };\n    // Determine gap based on layout\n    const getGap = ()=>{\n        switch(currentLayout){\n            case \"mobile\":\n                return 8;\n            case \"tablet\":\n                return 12;\n            case \"desktop\":\n            default:\n                return 16;\n        }\n    };\n    // Convert card size to column and row span - FIXED LOGIC\n    const getCardSize = (card)=>{\n        const [colSpan, rowSpan] = card.size.split(\"x\").map(Number);\n        // Adapt size based on layout\n        if (currentLayout === \"mobile\") {\n            // On mobile, limit to 2 columns max\n            const adaptedColSpan = Math.min(colSpan, 2);\n            return {\n                colSpan: adaptedColSpan,\n                rowSpan\n            };\n        } else if (currentLayout === \"tablet\") {\n            // On tablet, limit to 4 columns max\n            const adaptedColSpan = Math.min(colSpan, 4);\n            return {\n                colSpan: adaptedColSpan,\n                rowSpan\n            };\n        } else {\n            // CORRECTION: On desktop, use the actual size from card.size, don't modify it\n            return {\n                colSpan: Math.min(colSpan, 12),\n                rowSpan: Math.min(rowSpan, 6)\n            };\n        }\n    };\n    // Check for collisions\n    const hasCollision = (cardId, col, row, colSpan, rowSpan)=>{\n        // Check grid boundaries\n        if (col < 0 || row < 0 || col + colSpan > getGridColumns() || row + rowSpan > getGridRows()) {\n            return true;\n        }\n        for (const card of cards){\n            if (card.id === cardId || !card.gridPosition) continue;\n            const { colSpan: cardColSpan, rowSpan: cardRowSpan } = getCardSize(card);\n            // Check if rectangles overlap\n            const overlap = !(col >= card.gridPosition.col + cardColSpan || // Right\n            col + colSpan <= card.gridPosition.col || // Left\n            row >= card.gridPosition.row + cardRowSpan || // Bottom\n            row + rowSpan <= card.gridPosition.row // Top\n            );\n            if (overlap) return true;\n        }\n        return false;\n    };\n    // Intelligent resize function\n    const handleIntelligentResize = (cardId, newCols, newRows)=>{\n        const card = cards.find((c)=>c.id === cardId);\n        if (!card || !card.gridPosition) return false;\n        const currentCol = card.gridPosition.col;\n        const currentRow = card.gridPosition.row;\n        // Check grid limits\n        if (currentCol + newCols > getGridColumns() || currentRow + newRows > getGridRows()) {\n            return false;\n        }\n        // Check for collisions\n        if (hasCollision(cardId, currentCol, currentRow, newCols, newRows)) {\n            return false;\n        }\n        return true;\n    };\n    // Convert cards to React-Grid-Layout format\n    const getLayoutItems = ()=>{\n        return cards.map((card)=>{\n            if (!card.gridPosition) return null;\n            const { colSpan, rowSpan } = getCardSize(card);\n            return {\n                i: card.id,\n                x: card.gridPosition.col,\n                y: card.gridPosition.row,\n                w: colSpan,\n                h: rowSpan,\n                static: isPreview,\n                maxW: getGridColumns(),\n                maxH: getGridRows()\n            };\n        }).filter(Boolean);\n    };\n    // Handle layout change from React-Grid-Layout\n    const handleLayoutChange = (layout)=>{\n        if (isPreview || isLayoutChanging) return;\n        // Set a flag to prevent multiple updates\n        setIsLayoutChanging(true);\n        // Process layout changes one by one to prevent cascading updates\n        const updates = layout.map((item)=>{\n            const card = cards.find((c)=>c.id === item.i);\n            if (card && card.gridPosition) {\n                if (card.gridPosition.col !== item.x || card.gridPosition.row !== item.y) {\n                    return {\n                        id: card.id,\n                        x: item.x,\n                        y: item.y\n                    };\n                }\n            }\n            return null;\n        }).filter(Boolean);\n        // Apply updates sequentially\n        if (updates.length > 0) {\n            // Only update the card that was actually moved by the user\n            const update = updates[0];\n            if (update) {\n                updateCard(update.id, {\n                    gridPosition: {\n                        col: update.x,\n                        row: update.y\n                    }\n                });\n            }\n        }\n        // Reset the flag after a short delay\n        setTimeout(()=>{\n            setIsLayoutChanging(false);\n        }, 100);\n    };\n    // Check if a cell is free (not occupied by any card)\n    const isCellFree = (row, col)=>{\n        if (row >= getGridRows() || col >= getGridColumns()) return false;\n        // Check if any card occupies this cell\n        for (const card of cards){\n            if (!card.gridPosition) continue;\n            const { colSpan, rowSpan } = getCardSize(card);\n            const cardStartCol = card.gridPosition.col;\n            const cardEndCol = cardStartCol + colSpan - 1;\n            const cardStartRow = card.gridPosition.row;\n            const cardEndRow = cardStartRow + rowSpan - 1;\n            if (col >= cardStartCol && col <= cardEndCol && row >= cardStartRow && row <= cardEndRow) {\n                return false;\n            }\n        }\n        return true;\n    };\n    // Function to add a new card at a specific position\n    const handleAddCard = async (row, col)=>{\n        // Check if the cell is free\n        if (!isCellFree(row, col) || addingCard) return;\n        setAddingCard(true);\n        try {\n            // Utiliser 2x2 par défaut pour tous les layouts\n            const cardSize = \"2x2\";\n            const newCard = {\n                title: \"Nouvelle Carte\",\n                description: \"Cliquez pour \\xe9diter cette carte\",\n                url: \"\",\n                backgroundColor: \"#6366f1\",\n                textColor: \"#ffffff\",\n                size: cardSize,\n                gridPosition: {\n                    col,\n                    row\n                }\n            };\n            const result = await addCard(newCard);\n            if (!result.success) {\n                alert(result.error);\n            } else {\n                // Open editor for the new card\n                onCardClick && onCardClick(result.cardId || \"\");\n            }\n        } catch (error) {\n            console.error(\"Error adding card:\", error);\n        } finally{\n            setAddingCard(false);\n        }\n    };\n    // Check plan limits\n    const canAddMoreCards = ()=>{\n        if (userPlan === \"free\") return cards.length < 3;\n        if (userPlan === \"starter\") return cards.length < 25;\n        return true; // Pro plan = unlimited\n    };\n    // Calculate grid height based on content\n    const gridHeight = getGridRows() * cellSize + (getGridRows() - 1) * getGap();\n    // Calculate all empty cells for the grid - FIXED\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const maxCols = getGridColumns();\n        const maxRows = getGridRows();\n        const emptyCells = [];\n        // Check each cell in the grid\n        for(let row = 0; row < maxRows; row++){\n            for(let col = 0; col < maxCols; col++){\n                if (isCellFree(row, col)) {\n                    // CORRECTION: Logique plus simple et cohérente\n                    if (currentLayout === \"desktop\") {\n                        // Pour desktop, vérifier l'espace pour une carte 2x2\n                        let hasSpace = true;\n                        // Vérifier si on a assez d'espace (2x2)\n                        if (col + 2 > maxCols || row + 2 > maxRows) {\n                            hasSpace = false;\n                        } else {\n                            // Vérifier que toutes les cellules nécessaires sont libres\n                            for(let r = row; r < row + 2; r++){\n                                for(let c = col; c < col + 2; c++){\n                                    if (!isCellFree(r, c)) {\n                                        hasSpace = false;\n                                        break;\n                                    }\n                                }\n                                if (!hasSpace) break;\n                            }\n                        }\n                        if (hasSpace) {\n                            emptyCells.push({\n                                row,\n                                col\n                            });\n                        }\n                    } else {\n                        // Pour mobile et tablet, ajouter directement\n                        emptyCells.push({\n                            row,\n                            col\n                        });\n                    }\n                }\n            }\n        }\n        setEmptyGridCells(emptyCells);\n    }, [\n        cards,\n        currentLayout,\n        mounted\n    ]);\n    // Use fallback values to ensure GridLayout always receives valid props\n    const safeGridWidth = gridDimensions.width || 1;\n    const safeCellSize = cellSize || 1;\n    if (!mounted) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full h-96 bg-gray-100 rounded-lg animate-pulse flex items-center justify-center\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-gray-400\",\n                children: \"Loading grid...\"\n            }, void 0, false, {\n                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                lineNumber: 346,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n            lineNumber: 345,\n            columnNumber: 7\n        }, undefined);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: gridRef,\n        className: \"relative touch-none \".concat(className),\n        style: {\n            height: gridHeight,\n            minHeight: \"300px\",\n            position: \"relative\"\n        },\n        children: isPreview ? // Preview mode - static grid\n        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                display: \"grid\",\n                gridTemplateColumns: \"repeat(\".concat(getGridColumns(), \", 1fr)\"),\n                gridTemplateRows: \"repeat(\".concat(getGridRows(), \", 1fr)\"),\n                gap: \"\".concat(getGap(), \"px\"),\n                height: \"100%\",\n                width: \"100%\"\n            },\n            children: cards.map((card)=>{\n                if (!card.gridPosition) return null;\n                // Get grid span\n                const { colSpan, rowSpan } = getCardSize(card);\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        gridColumn: \"\".concat(card.gridPosition.col + 1, \" / span \").concat(colSpan),\n                        gridRow: \"\".concat(card.gridPosition.row + 1, \" / span \").concat(rowSpan),\n                        position: \"relative\"\n                    },\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_BentoCardComponent__WEBPACK_IMPORTED_MODULE_3__.BentoCardComponent, {\n                        card: card,\n                        isPreviewMode: true\n                    }, void 0, false, {\n                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                        lineNumber: 388,\n                        columnNumber: 17\n                    }, undefined)\n                }, card.id, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 380,\n                    columnNumber: 15\n                }, undefined);\n            })\n        }, void 0, false, {\n            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n            lineNumber: 363,\n            columnNumber: 9\n        }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_grid_layout__WEBPACK_IMPORTED_MODULE_4___default()), {\n                    className: \"layout\",\n                    layout: getLayoutItems(),\n                    cols: getGridColumns(),\n                    rowHeight: safeCellSize,\n                    width: safeGridWidth,\n                    margin: [\n                        getGap(),\n                        getGap()\n                    ],\n                    containerPadding: [\n                        0,\n                        0\n                    ],\n                    onLayoutChange: handleLayoutChange,\n                    isDraggable: !isPreview && currentLayout === \"desktop\",\n                    isResizable: false,\n                    compactType: null,\n                    preventCollision: true,\n                    useCSSTransforms: true,\n                    draggableHandle: \".drag-handle\",\n                    maxRows: getGridRows(),\n                    resizeHandles: [],\n                    children: cards.map((card)=>{\n                        if (!card.gridPosition) return null;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"h-full w-full\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ResizableCard__WEBPACK_IMPORTED_MODULE_6__.ResizableCard, {\n                                card: card,\n                                cellSize: safeCellSize,\n                                gap: getGap(),\n                                maxCols: getGridColumns(),\n                                maxRows: getGridRows(),\n                                onIntelligentResize: handleIntelligentResize,\n                                onEdit: ()=>onCardClick && onCardClick(card.id)\n                            }, void 0, false, {\n                                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                lineNumber: 421,\n                                columnNumber: 19\n                            }, undefined)\n                        }, card.id, false, {\n                            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                            lineNumber: 420,\n                            columnNumber: 17\n                        }, undefined);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 398,\n                    columnNumber: 11\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute inset-0 pointer-events-none\",\n                    style: {\n                        display: \"grid\",\n                        gridTemplateColumns: \"repeat(\".concat(getGridColumns(), \", 1fr)\"),\n                        gridTemplateRows: \"repeat(\".concat(getGridRows(), \", 1fr)\"),\n                        gap: \"\".concat(getGap(), \"px\"),\n                        zIndex: 5\n                    },\n                    children: emptyGridCells.map((param)=>{\n                        let { row, col } = param;\n                        const isHovered = (hoveredCell === null || hoveredCell === void 0 ? void 0 : hoveredCell.row) === row && (hoveredCell === null || hoveredCell === void 0 ? void 0 : hoveredCell.col) === col;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                gridColumn: col + 1,\n                                gridRow: row + 1,\n                                position: \"relative\"\n                            },\n                            className: \"cursor-pointer pointer-events-auto\",\n                            onMouseEnter: ()=>setHoveredCell({\n                                    row,\n                                    col\n                                }),\n                            onMouseLeave: ()=>setHoveredCell(null),\n                            onClick: ()=>handleAddCard(row, col),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_7__.motion.div, {\n                                initial: {\n                                    opacity: 0\n                                },\n                                animate: {\n                                    opacity: isHovered ? 1 : 0,\n                                    scale: isHovered ? 1 : 0.8\n                                },\n                                className: \"absolute inset-0 rounded-lg border-2 border-dashed border-indigo-500/40 bg-indigo-500/10 flex items-center justify-center\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_7__.motion.div, {\n                                    whileHover: {\n                                        scale: 1.1\n                                    },\n                                    whileTap: {\n                                        scale: 0.9\n                                    },\n                                    className: \"p-2 rounded-full \".concat(canAddMoreCards() ? \"bg-indigo-500 text-white\" : \"bg-red-500 text-white\"),\n                                    children: canAddMoreCards() ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                        size: 16\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                        lineNumber: 481,\n                                        columnNumber: 25\n                                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Crown_Plus_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                        size: 16\n                                    }, void 0, false, {\n                                        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                        lineNumber: 483,\n                                        columnNumber: 25\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                    lineNumber: 471,\n                                    columnNumber: 21\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                                lineNumber: 463,\n                                columnNumber: 19\n                            }, undefined)\n                        }, \"cell-\".concat(row, \"-\").concat(col), false, {\n                            fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                            lineNumber: 450,\n                            columnNumber: 17\n                        }, undefined);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n                    lineNumber: 436,\n                    columnNumber: 11\n                }, undefined)\n            ]\n        }, void 0, true)\n    }, void 0, false, {\n        fileName: \"/Users/dejonghe/Desktop/MosaLink-bolt/src/components/BentoGrid.tsx\",\n        lineNumber: 352,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BentoGrid, \"s7/xGUKjl5RzpRMxEcelZleSZs0=\", false, function() {\n    return [\n        _store_useStore__WEBPACK_IMPORTED_MODULE_2__.useStore\n    ];\n});\n_c = BentoGrid;\n/* harmony default export */ __webpack_exports__[\"default\"] = (BentoGrid);\nvar _c;\n$RefreshReg$(_c, \"BentoGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0JlbnRvR3JpZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTJEO0FBQ0g7QUFDWDtBQUVhO0FBQ1Q7QUFDTjtBQUNEO0FBQ007QUFTekMsTUFBTVcsWUFBc0M7UUFBQyxFQUNsREMsS0FBSyxFQUNMQyxZQUFZLEtBQUssRUFDakJDLFdBQVcsRUFDWEMsWUFBWSxFQUFFLEVBQ2Y7O0lBQ0MsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUUsR0FBR2QseURBQVFBO0lBQ2pFLE1BQU0sQ0FBQ2UsZ0JBQWdCQyxrQkFBa0IsR0FBR3BCLCtDQUFRQSxDQUFDO1FBQUVxQixPQUFPO1FBQUdDLFFBQVE7SUFBRTtJQUMzRSxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR3hCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ3lCLGFBQWFDLGVBQWUsR0FBRzFCLCtDQUFRQSxDQUFzQztJQUNwRixNQUFNMkIsVUFBVXpCLDZDQUFNQSxDQUFpQjtJQUN2QyxNQUFNLENBQUMwQixTQUFTQyxXQUFXLEdBQUc3QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUM4QixrQkFBa0JDLG9CQUFvQixHQUFHL0IsK0NBQVFBLENBQUM7SUFDekQsTUFBTSxDQUFDZ0MsWUFBWUMsY0FBYyxHQUFHakMsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDa0MsZ0JBQWdCQyxrQkFBa0IsR0FBR25DLCtDQUFRQSxDQUErQixFQUFFO0lBRXJGLGdEQUFnRDtJQUNoREMsZ0RBQVNBLENBQUM7UUFDUjRCLFdBQVc7UUFFWCxNQUFNTyxzQkFBc0I7WUFDMUIsSUFBSVQsUUFBUVUsT0FBTyxFQUFFO2dCQUNuQixNQUFNQyxPQUFPWCxRQUFRVSxPQUFPLENBQUNFLHFCQUFxQjtnQkFDbERuQixrQkFBa0I7b0JBQUVDLE9BQU9pQixLQUFLakIsS0FBSztvQkFBRUMsUUFB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QU04Q04scURBQVFBOzs7S0FOdERNO0FBNmRiLCtEQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0JlbnRvR3JpZC50c3g/NGM4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtb3Rpb24sIEFuaW1hdGVQcmVzZW5jZSB9IGZyb20gJ2ZyYW1lci1tb3Rpb24nO1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICcuLi9zdG9yZS91c2VTdG9yZSc7XG5pbXBvcnQgeyBCZW50b0NhcmQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBCZW50b0NhcmRDb21wb25lbnQgfSBmcm9tICcuL0JlbnRvQ2FyZENvbXBvbmVudCc7XG5pbXBvcnQgeyBQbHVzLCBDcm93biwgTW92ZSB9IGZyb20gJ2x1Y2lkZS1yZWFjdCc7XG5pbXBvcnQgR3JpZExheW91dCBmcm9tICdyZWFjdC1ncmlkLWxheW91dCc7XG5pbXBvcnQgJ3JlYWN0LWdyaWQtbGF5b3V0L2Nzcy9zdHlsZXMuY3NzJztcbmltcG9ydCB7IFJlc2l6YWJsZUNhcmQgfSBmcm9tICcuL1Jlc2l6YWJsZUNhcmQnO1xuXG5pbnRlcmZhY2UgQmVudG9HcmlkUHJvcHMge1xuICBjYXJkczogQmVudG9DYXJkW107XG4gIGlzUHJldmlldz86IGJvb2xlYW47XG4gIG9uQ2FyZENsaWNrPzogKGNhcmRJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBCZW50b0dyaWQ6IFJlYWN0LkZDPEJlbnRvR3JpZFByb3BzPiA9ICh7XG4gIGNhcmRzLFxuICBpc1ByZXZpZXcgPSBmYWxzZSxcbiAgb25DYXJkQ2xpY2ssXG4gIGNsYXNzTmFtZSA9ICcnXG59KSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudExheW91dCwgdXBkYXRlQ2FyZCwgYWRkQ2FyZCwgdXNlclBsYW4gfSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IFtncmlkRGltZW5zaW9ucywgc2V0R3JpZERpbWVuc2lvbnNdID0gdXNlU3RhdGUoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICBjb25zdCBbY2VsbFNpemUsIHNldENlbGxTaXplXSA9IHVzZVN0YXRlKDEwMCk7XG4gIGNvbnN0IFtob3ZlcmVkQ2VsbCwgc2V0SG92ZXJlZENlbGxdID0gdXNlU3RhdGU8eyByb3c6IG51bWJlcjsgY29sOiBudW1iZXIgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBncmlkUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMYXlvdXRDaGFuZ2luZywgc2V0SXNMYXlvdXRDaGFuZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFthZGRpbmdDYXJkLCBzZXRBZGRpbmdDYXJkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2VtcHR5R3JpZENlbGxzLCBzZXRFbXB0eUdyaWRDZWxsc10gPSB1c2VTdGF0ZTx7cm93OiBudW1iZXIsIGNvbDogbnVtYmVyfVtdPihbXSk7XG4gIFxuICAvLyBDYWxjdWxhdGUgZ3JpZCBkaW1lbnNpb25zIG9uIG1vdW50IGFuZCByZXNpemVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICAgIFxuICAgIGNvbnN0IGNhbGN1bGF0ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICBpZiAoZ3JpZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBncmlkUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHNldEdyaWREaW1lbnNpb25zKHsgd2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcmVjdC5oZWlnaHQgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgY2VsbCBzaXplIGJhc2VkIG9uIGdyaWQgd2lkdGggYW5kIGNvbHVtbnNcbiAgICAgICAgY29uc3QgY29scyA9IGdldEdyaWRDb2x1bW5zKCk7XG4gICAgICAgIGNvbnN0IGdhcFNpemUgPSBnZXRHYXAoKTtcbiAgICAgICAgY29uc3QgdG90YWxHYXBXaWR0aCA9IGdhcFNpemUgKiAoY29scyAtIDEpO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IHJlY3Qud2lkdGggLSB0b3RhbEdhcFdpZHRoO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkQ2VsbFNpemUgPSBNYXRoLmZsb29yKGF2YWlsYWJsZVdpZHRoIC8gY29scyk7XG4gICAgICAgIHNldENlbGxTaXplKGNhbGN1bGF0ZWRDZWxsU2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBjYWxjdWxhdGVEaW1lbnNpb25zKCk7XG4gICAgXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoY2FsY3VsYXRlRGltZW5zaW9ucyk7XG4gICAgaWYgKGdyaWRSZWYuY3VycmVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShncmlkUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgICBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgY2FsY3VsYXRlRGltZW5zaW9ucyk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBjYWxjdWxhdGVEaW1lbnNpb25zKTtcbiAgICB9O1xuICB9LCBbY3VycmVudExheW91dF0pO1xuICBcbiAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBjb2x1bW5zIGJhc2VkIG9uIGxheW91dFxuICBjb25zdCBnZXRHcmlkQ29sdW1ucyA9ICgpID0+IHtcbiAgICBjb25zdCBjb2xzID0gKCgpID0+IHtcbiAgICAgIHN3aXRjaCAoY3VycmVudExheW91dCkge1xuICAgICAgICBjYXNlICdtb2JpbGUnOiByZXR1cm4gMjtcbiAgICAgICAgY2FzZSAndGFibGV0JzogcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgJ2Rlc2t0b3AnOiBkZWZhdWx0OiByZXR1cm4gMTI7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICBcbiAgICByZXR1cm4gY29scztcbiAgfTtcbiAgXG4gIC8vIERldGVybWluZSBudW1iZXIgb2Ygcm93cyBiYXNlZCBvbiBsYXlvdXQgLSBGSVhFRCBUTyA2IFJPV1MgTUFYXG4gIGNvbnN0IGdldEdyaWRSb3dzID0gKCkgPT4ge1xuICAgIHN3aXRjaCAoY3VycmVudExheW91dCkge1xuICAgICAgY2FzZSAnbW9iaWxlJzogcmV0dXJuIDY7XG4gICAgICBjYXNlICd0YWJsZXQnOiByZXR1cm4gNjtcbiAgICAgIGNhc2UgJ2Rlc2t0b3AnOiBkZWZhdWx0OiByZXR1cm4gNjtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBEZXRlcm1pbmUgZ2FwIGJhc2VkIG9uIGxheW91dFxuICBjb25zdCBnZXRHYXAgPSAoKSA9PiB7XG4gICAgc3dpdGNoIChjdXJyZW50TGF5b3V0KSB7XG4gICAgICBjYXNlICdtb2JpbGUnOiByZXR1cm4gODtcbiAgICAgIGNhc2UgJ3RhYmxldCc6IHJldHVybiAxMjtcbiAgICAgIGNhc2UgJ2Rlc2t0b3AnOiBkZWZhdWx0OiByZXR1cm4gMTY7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gQ29udmVydCBjYXJkIHNpemUgdG8gY29sdW1uIGFuZCByb3cgc3BhbiAtIEZJWEVEIExPR0lDXG4gIGNvbnN0IGdldENhcmRTaXplID0gKGNhcmQ6IEJlbnRvQ2FyZCkgPT4ge1xuICAgIGNvbnN0IFtjb2xTcGFuLCByb3dTcGFuXSA9IGNhcmQuc2l6ZS5zcGxpdCgneCcpLm1hcChOdW1iZXIpO1xuICAgIFxuICAgIC8vIEFkYXB0IHNpemUgYmFzZWQgb24gbGF5b3V0XG4gICAgaWYgKGN1cnJlbnRMYXlvdXQgPT09ICdtb2JpbGUnKSB7XG4gICAgICAvLyBPbiBtb2JpbGUsIGxpbWl0IHRvIDIgY29sdW1ucyBtYXhcbiAgICAgIGNvbnN0IGFkYXB0ZWRDb2xTcGFuID0gTWF0aC5taW4oY29sU3BhbiwgMik7XG4gICAgICByZXR1cm4geyBjb2xTcGFuOiBhZGFwdGVkQ29sU3Bhbiwgcm93U3BhbiB9O1xuICAgIH0gZWxzZSBpZiAoY3VycmVudExheW91dCA9PT0gJ3RhYmxldCcpIHtcbiAgICAgIC8vIE9uIHRhYmxldCwgbGltaXQgdG8gNCBjb2x1bW5zIG1heFxuICAgICAgY29uc3QgYWRhcHRlZENvbFNwYW4gPSBNYXRoLm1pbihjb2xTcGFuLCA0KTtcbiAgICAgIHJldHVybiB7IGNvbFNwYW46IGFkYXB0ZWRDb2xTcGFuLCByb3dTcGFuIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENPUlJFQ1RJT046IE9uIGRlc2t0b3AsIHVzZSB0aGUgYWN0dWFsIHNpemUgZnJvbSBjYXJkLnNpemUsIGRvbid0IG1vZGlmeSBpdFxuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIGNvbFNwYW46IE1hdGgubWluKGNvbFNwYW4sIDEyKSwgXG4gICAgICAgIHJvd1NwYW46IE1hdGgubWluKHJvd1NwYW4sIDYpIFxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBDaGVjayBmb3IgY29sbGlzaW9uc1xuICBjb25zdCBoYXNDb2xsaXNpb24gPSAoY2FyZElkOiBzdHJpbmcsIGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgY29sU3BhbjogbnVtYmVyLCByb3dTcGFuOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICAvLyBDaGVjayBncmlkIGJvdW5kYXJpZXNcbiAgICBpZiAoY29sIDwgMCB8fCByb3cgPCAwIHx8IGNvbCArIGNvbFNwYW4gPiBnZXRHcmlkQ29sdW1ucygpIHx8IHJvdyArIHJvd1NwYW4gPiBnZXRHcmlkUm93cygpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgZm9yIChjb25zdCBjYXJkIG9mIGNhcmRzKSB7XG4gICAgICBpZiAoY2FyZC5pZCA9PT0gY2FyZElkIHx8ICFjYXJkLmdyaWRQb3NpdGlvbikgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgY29sU3BhbjogY2FyZENvbFNwYW4sIHJvd1NwYW46IGNhcmRSb3dTcGFuIH0gPSBnZXRDYXJkU2l6ZShjYXJkKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgcmVjdGFuZ2xlcyBvdmVybGFwXG4gICAgICBjb25zdCBvdmVybGFwID0gIShcbiAgICAgICAgY29sID49IGNhcmQuZ3JpZFBvc2l0aW9uLmNvbCArIGNhcmRDb2xTcGFuIHx8IC8vIFJpZ2h0XG4gICAgICAgIGNvbCArIGNvbFNwYW4gPD0gY2FyZC5ncmlkUG9zaXRpb24uY29sIHx8ICAgICAvLyBMZWZ0XG4gICAgICAgIHJvdyA+PSBjYXJkLmdyaWRQb3NpdGlvbi5yb3cgKyBjYXJkUm93U3BhbiB8fCAvLyBCb3R0b21cbiAgICAgICAgcm93ICsgcm93U3BhbiA8PSBjYXJkLmdyaWRQb3NpdGlvbi5yb3cgICAgICAgIC8vIFRvcFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKG92ZXJsYXApIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gSW50ZWxsaWdlbnQgcmVzaXplIGZ1bmN0aW9uXG4gIGNvbnN0IGhhbmRsZUludGVsbGlnZW50UmVzaXplID0gKGNhcmRJZDogc3RyaW5nLCBuZXdDb2xzOiBudW1iZXIsIG5ld1Jvd3M6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IGNhcmQgPSBjYXJkcy5maW5kKGMgPT4gYy5pZCA9PT0gY2FyZElkKTtcbiAgICBpZiAoIWNhcmQgfHwgIWNhcmQuZ3JpZFBvc2l0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgY3VycmVudENvbCA9IGNhcmQuZ3JpZFBvc2l0aW9uLmNvbDtcbiAgICBjb25zdCBjdXJyZW50Um93ID0gY2FyZC5ncmlkUG9zaXRpb24ucm93O1xuICAgIFxuICAgIC8vIENoZWNrIGdyaWQgbGltaXRzXG4gICAgaWYgKGN1cnJlbnRDb2wgKyBuZXdDb2xzID4gZ2V0R3JpZENvbHVtbnMoKSB8fCBjdXJyZW50Um93ICsgbmV3Um93cyA+IGdldEdyaWRSb3dzKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnNcbiAgICBpZiAoaGFzQ29sbGlzaW9uKGNhcmRJZCwgY3VycmVudENvbCwgY3VycmVudFJvdywgbmV3Q29scywgbmV3Um93cykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIFxuICAvLyBDb252ZXJ0IGNhcmRzIHRvIFJlYWN0LUdyaWQtTGF5b3V0IGZvcm1hdFxuICBjb25zdCBnZXRMYXlvdXRJdGVtcyA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FyZHMubWFwKGNhcmQgPT4ge1xuICAgICAgaWYgKCFjYXJkLmdyaWRQb3NpdGlvbikgcmV0dXJuIG51bGw7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgY29sU3Bhbiwgcm93U3BhbiB9ID0gZ2V0Q2FyZFNpemUoY2FyZCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGk6IGNhcmQuaWQsXG4gICAgICAgIHg6IGNhcmQuZ3JpZFBvc2l0aW9uLmNvbCxcbiAgICAgICAgeTogY2FyZC5ncmlkUG9zaXRpb24ucm93LFxuICAgICAgICB3OiBjb2xTcGFuLFxuICAgICAgICBoOiByb3dTcGFuLFxuICAgICAgICBzdGF0aWM6IGlzUHJldmlldyxcbiAgICAgICAgbWF4VzogZ2V0R3JpZENvbHVtbnMoKSxcbiAgICAgICAgbWF4SDogZ2V0R3JpZFJvd3MoKVxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgR3JpZExheW91dC5MYXlvdXRbXTtcbiAgfTtcbiAgXG4gIC8vIEhhbmRsZSBsYXlvdXQgY2hhbmdlIGZyb20gUmVhY3QtR3JpZC1MYXlvdXRcbiAgY29uc3QgaGFuZGxlTGF5b3V0Q2hhbmdlID0gKGxheW91dDogR3JpZExheW91dC5MYXlvdXRbXSkgPT4ge1xuICAgIGlmIChpc1ByZXZpZXcgfHwgaXNMYXlvdXRDaGFuZ2luZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIFNldCBhIGZsYWcgdG8gcHJldmVudCBtdWx0aXBsZSB1cGRhdGVzXG4gICAgc2V0SXNMYXlvdXRDaGFuZ2luZyh0cnVlKTtcbiAgICBcbiAgICAvLyBQcm9jZXNzIGxheW91dCBjaGFuZ2VzIG9uZSBieSBvbmUgdG8gcHJldmVudCBjYXNjYWRpbmcgdXBkYXRlc1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBsYXlvdXQubWFwKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgY2FyZCA9IGNhcmRzLmZpbmQoYyA9PiBjLmlkID09PSBpdGVtLmkpO1xuICAgICAgaWYgKGNhcmQgJiYgY2FyZC5ncmlkUG9zaXRpb24pIHtcbiAgICAgICAgaWYgKGNhcmQuZ3JpZFBvc2l0aW9uLmNvbCAhPT0gaXRlbS54IHx8IGNhcmQuZ3JpZFBvc2l0aW9uLnJvdyAhPT0gaXRlbS55KSB7XG4gICAgICAgICAgcmV0dXJuIHsgaWQ6IGNhcmQuaWQsIHg6IGl0ZW0ueCwgeTogaXRlbS55IH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICBcbiAgICAvLyBBcHBseSB1cGRhdGVzIHNlcXVlbnRpYWxseVxuICAgIGlmICh1cGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBjYXJkIHRoYXQgd2FzIGFjdHVhbGx5IG1vdmVkIGJ5IHRoZSB1c2VyXG4gICAgICBjb25zdCB1cGRhdGUgPSB1cGRhdGVzWzBdO1xuICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICB1cGRhdGVDYXJkKHVwZGF0ZS5pZCwge1xuICAgICAgICAgIGdyaWRQb3NpdGlvbjogeyBjb2w6IHVwZGF0ZS54LCByb3c6IHVwZGF0ZS55IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc2V0IHRoZSBmbGFnIGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldElzTGF5b3V0Q2hhbmdpbmcoZmFsc2UpO1xuICAgIH0sIDEwMCk7XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgYSBjZWxsIGlzIGZyZWUgKG5vdCBvY2N1cGllZCBieSBhbnkgY2FyZClcbiAgY29uc3QgaXNDZWxsRnJlZSA9IChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpID0+IHtcbiAgICBpZiAocm93ID49IGdldEdyaWRSb3dzKCkgfHwgY29sID49IGdldEdyaWRDb2x1bW5zKCkpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbnkgY2FyZCBvY2N1cGllcyB0aGlzIGNlbGxcbiAgICBmb3IgKGNvbnN0IGNhcmQgb2YgY2FyZHMpIHtcbiAgICAgIGlmICghY2FyZC5ncmlkUG9zaXRpb24pIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCB7IGNvbFNwYW4sIHJvd1NwYW4gfSA9IGdldENhcmRTaXplKGNhcmQpO1xuICAgICAgY29uc3QgY2FyZFN0YXJ0Q29sID0gY2FyZC5ncmlkUG9zaXRpb24uY29sO1xuICAgICAgY29uc3QgY2FyZEVuZENvbCA9IGNhcmRTdGFydENvbCArIGNvbFNwYW4gLSAxO1xuICAgICAgY29uc3QgY2FyZFN0YXJ0Um93ID0gY2FyZC5ncmlkUG9zaXRpb24ucm93O1xuICAgICAgY29uc3QgY2FyZEVuZFJvdyA9IGNhcmRTdGFydFJvdyArIHJvd1NwYW4gLSAxO1xuICAgICAgXG4gICAgICBpZiAoY29sID49IGNhcmRTdGFydENvbCAmJiBjb2wgPD0gY2FyZEVuZENvbCAmJiBcbiAgICAgICAgICByb3cgPj0gY2FyZFN0YXJ0Um93ICYmIHJvdyA8PSBjYXJkRW5kUm93KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gdG8gYWRkIGEgbmV3IGNhcmQgYXQgYSBzcGVjaWZpYyBwb3NpdGlvblxuICBjb25zdCBoYW5kbGVBZGRDYXJkID0gYXN5bmMgKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcikgPT4ge1xuICAvLyBDaGVjayBpZiB0aGUgY2VsbCBpcyBmcmVlXG4gIGlmICghaXNDZWxsRnJlZShyb3csIGNvbCkgfHwgYWRkaW5nQ2FyZCkgcmV0dXJuO1xuICBcbiAgc2V0QWRkaW5nQ2FyZCh0cnVlKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gVXRpbGlzZXIgMngyIHBhciBkw6lmYXV0IHBvdXIgdG91cyBsZXMgbGF5b3V0c1xuICAgIGNvbnN0IGNhcmRTaXplID0gJzJ4Mic7XG4gICAgXG4gICAgY29uc3QgbmV3Q2FyZCA9IHtcbiAgICAgIHRpdGxlOiAnTm91dmVsbGUgQ2FydGUnLFxuICAgICAgZGVzY3JpcHRpb246ICdDbGlxdWV6IHBvdXIgw6lkaXRlciBjZXR0ZSBjYXJ0ZScsXG4gICAgICB1cmw6ICcnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzYzNjZmMScsXG4gICAgICB0ZXh0Q29sb3I6ICcjZmZmZmZmJyxcbiAgICAgIHNpemU6IGNhcmRTaXplIGFzIGFueSxcbiAgICAgIGdyaWRQb3NpdGlvbjogeyBjb2wsIHJvdyB9XG4gICAgfTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZGRDYXJkKG5ld0NhcmQpO1xuICAgIFxuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGFsZXJ0KHJlc3VsdC5lcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9wZW4gZWRpdG9yIGZvciB0aGUgbmV3IGNhcmRcbiAgICAgIG9uQ2FyZENsaWNrICYmIG9uQ2FyZENsaWNrKHJlc3VsdC5jYXJkSWQgfHwgJycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIGNhcmQ6XCIsIGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRBZGRpbmdDYXJkKGZhbHNlKTtcbiAgfVxuICB9O1xuXG4gIC8vIENoZWNrIHBsYW4gbGltaXRzXG4gIGNvbnN0IGNhbkFkZE1vcmVDYXJkcyA9ICgpID0+IHtcbiAgICBpZiAodXNlclBsYW4gPT09ICdmcmVlJykgcmV0dXJuIGNhcmRzLmxlbmd0aCA8IDM7XG4gICAgaWYgKHVzZXJQbGFuID09PSAnc3RhcnRlcicpIHJldHVybiBjYXJkcy5sZW5ndGggPCAyNTtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gUHJvIHBsYW4gPSB1bmxpbWl0ZWRcbiAgfTtcblxuICAvLyBDYWxjdWxhdGUgZ3JpZCBoZWlnaHQgYmFzZWQgb24gY29udGVudFxuICBjb25zdCBncmlkSGVpZ2h0ID0gZ2V0R3JpZFJvd3MoKSAqIGNlbGxTaXplICsgKGdldEdyaWRSb3dzKCkgLSAxKSAqIGdldEdhcCgpO1xuXG4gIC8vIENhbGN1bGF0ZSBhbGwgZW1wdHkgY2VsbHMgZm9yIHRoZSBncmlkIC0gRklYRURcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBtYXhDb2xzID0gZ2V0R3JpZENvbHVtbnMoKTtcbiAgICBjb25zdCBtYXhSb3dzID0gZ2V0R3JpZFJvd3MoKTtcbiAgICBjb25zdCBlbXB0eUNlbGxzOiB7cm93OiBudW1iZXIsIGNvbDogbnVtYmVyfVtdID0gW107XG4gICAgXG4gICAgLy8gQ2hlY2sgZWFjaCBjZWxsIGluIHRoZSBncmlkXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWF4Um93czsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IG1heENvbHM7IGNvbCsrKSB7XG4gICAgICAgIGlmIChpc0NlbGxGcmVlKHJvdywgY29sKSkge1xuICAgICAgICAgIC8vIENPUlJFQ1RJT046IExvZ2lxdWUgcGx1cyBzaW1wbGUgZXQgY29ow6lyZW50ZVxuICAgICAgICAgIGlmIChjdXJyZW50TGF5b3V0ID09PSAnZGVza3RvcCcpIHtcbiAgICAgICAgICAgIC8vIFBvdXIgZGVza3RvcCwgdsOpcmlmaWVyIGwnZXNwYWNlIHBvdXIgdW5lIGNhcnRlIDJ4MlxuICAgICAgICAgICAgbGV0IGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVsOpcmlmaWVyIHNpIG9uIGEgYXNzZXogZCdlc3BhY2UgKDJ4MilcbiAgICAgICAgICAgIGlmIChjb2wgKyAyID4gbWF4Q29scyB8fCByb3cgKyAyID4gbWF4Um93cykge1xuICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVsOpcmlmaWVyIHF1ZSB0b3V0ZXMgbGVzIGNlbGx1bGVzIG7DqWNlc3NhaXJlcyBzb250IGxpYnJlc1xuICAgICAgICAgICAgICBmb3IgKGxldCByID0gcm93OyByIDwgcm93ICsgMjsgcisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNvbDsgYyA8IGNvbCArIDI7IGMrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc0NlbGxGcmVlKHIsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NwYWNlKSBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGFzU3BhY2UpIHtcbiAgICAgICAgICAgICAgZW1wdHlDZWxscy5wdXNoKHsgcm93LCBjb2wgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBvdXIgbW9iaWxlIGV0IHRhYmxldCwgYWpvdXRlciBkaXJlY3RlbWVudFxuICAgICAgICAgICAgZW1wdHlDZWxscy5wdXNoKHsgcm93LCBjb2wgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHNldEVtcHR5R3JpZENlbGxzKGVtcHR5Q2VsbHMpO1xuICB9LCBbY2FyZHMsIGN1cnJlbnRMYXlvdXQsIG1vdW50ZWRdKTtcbiAgXG4gIC8vIFVzZSBmYWxsYmFjayB2YWx1ZXMgdG8gZW5zdXJlIEdyaWRMYXlvdXQgYWx3YXlzIHJlY2VpdmVzIHZhbGlkIHByb3BzXG4gIGNvbnN0IHNhZmVHcmlkV2lkdGggPSBncmlkRGltZW5zaW9ucy53aWR0aCB8fCAxO1xuICBjb25zdCBzYWZlQ2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAxO1xuXG4gIGlmICghbW91bnRlZCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLTk2IGJnLWdyYXktMTAwIHJvdW5kZWQtbGcgYW5pbWF0ZS1wdWxzZSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDBcIj5Mb2FkaW5nIGdyaWQuLi48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbiAgXG4gIHJldHVybiAoXG4gICAgPGRpdiBcbiAgICAgIHJlZj17Z3JpZFJlZn1cbiAgICAgIGNsYXNzTmFtZT17YHJlbGF0aXZlIHRvdWNoLW5vbmUgJHtjbGFzc05hbWV9YH1cbiAgICAgIHN0eWxlPXt7IFxuICAgICAgICBoZWlnaHQ6IGdyaWRIZWlnaHQsXG4gICAgICAgIG1pbkhlaWdodDogJzMwMHB4JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH19XG4gICAgPlxuICAgICAge2lzUHJldmlldyA/IChcbiAgICAgICAgLy8gUHJldmlldyBtb2RlIC0gc3RhdGljIGdyaWRcbiAgICAgICAgPGRpdlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBgcmVwZWF0KCR7Z2V0R3JpZENvbHVtbnMoKX0sIDFmcilgLFxuICAgICAgICAgICAgZ3JpZFRlbXBsYXRlUm93czogYHJlcGVhdCgke2dldEdyaWRSb3dzKCl9LCAxZnIpYCxcbiAgICAgICAgICAgIGdhcDogYCR7Z2V0R2FwKCl9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtjYXJkcy5tYXAoKGNhcmQpID0+IHtcbiAgICAgICAgICAgIGlmICghY2FyZC5ncmlkUG9zaXRpb24pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZXQgZ3JpZCBzcGFuXG4gICAgICAgICAgICBjb25zdCB7IGNvbFNwYW4sIHJvd1NwYW4gfSA9IGdldENhcmRTaXplKGNhcmQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIGtleT17Y2FyZC5pZH1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogYCR7Y2FyZC5ncmlkUG9zaXRpb24uY29sICsgMX0gLyBzcGFuICR7Y29sU3Bhbn1gLFxuICAgICAgICAgICAgICAgICAgZ3JpZFJvdzogYCR7Y2FyZC5ncmlkUG9zaXRpb24ucm93ICsgMX0gLyBzcGFuICR7cm93U3Bhbn1gLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPEJlbnRvQ2FyZENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgY2FyZD17Y2FyZH1cbiAgICAgICAgICAgICAgICAgIGlzUHJldmlld01vZGU9e3RydWV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPEdyaWRMYXlvdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImxheW91dFwiXG4gICAgICAgICAgICBsYXlvdXQ9e2dldExheW91dEl0ZW1zKCl9XG4gICAgICAgICAgICBjb2xzPXtnZXRHcmlkQ29sdW1ucygpfVxuICAgICAgICAgICAgcm93SGVpZ2h0PXtzYWZlQ2VsbFNpemV9XG4gICAgICAgICAgICB3aWR0aD17c2FmZUdyaWRXaWR0aH1cbiAgICAgICAgICAgIG1hcmdpbj17W2dldEdhcCgpLCBnZXRHYXAoKV19XG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nPXtbMCwgMF19XG4gICAgICAgICAgICBvbkxheW91dENoYW5nZT17aGFuZGxlTGF5b3V0Q2hhbmdlfVxuICAgICAgICAgICAgaXNEcmFnZ2FibGU9eyFpc1ByZXZpZXcgJiYgY3VycmVudExheW91dCA9PT0gJ2Rlc2t0b3AnfVxuICAgICAgICAgICAgaXNSZXNpemFibGU9e2ZhbHNlfSAgLy8gRGlzYWJsZSBSR0wncyBidWlsdC1pbiByZXNpemVcbiAgICAgICAgICAgIGNvbXBhY3RUeXBlPXtudWxsfVxuICAgICAgICAgICAgcHJldmVudENvbGxpc2lvbj17dHJ1ZX1cbiAgICAgICAgICAgIHVzZUNTU1RyYW5zZm9ybXM9e3RydWV9XG4gICAgICAgICAgICBkcmFnZ2FibGVIYW5kbGU9XCIuZHJhZy1oYW5kbGVcIlxuICAgICAgICAgICAgbWF4Um93cz17Z2V0R3JpZFJvd3MoKX1cbiAgICAgICAgICAgIHJlc2l6ZUhhbmRsZXM9e1tdfSAgLy8gUmVtb3ZlIGFsbCBSR0wgcmVzaXplIGhhbmRsZXNcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2FyZHMubWFwKChjYXJkKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghY2FyZC5ncmlkUG9zaXRpb24pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT17Y2FyZC5pZH0gY2xhc3NOYW1lPVwiaC1mdWxsIHctZnVsbFwiPlxuICAgICAgICAgICAgICAgICAgPFJlc2l6YWJsZUNhcmRcbiAgICAgICAgICAgICAgICAgICAgY2FyZD17Y2FyZH1cbiAgICAgICAgICAgICAgICAgICAgY2VsbFNpemU9e3NhZmVDZWxsU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgZ2FwPXtnZXRHYXAoKX1cbiAgICAgICAgICAgICAgICAgICAgbWF4Q29scz17Z2V0R3JpZENvbHVtbnMoKX1cbiAgICAgICAgICAgICAgICAgICAgbWF4Um93cz17Z2V0R3JpZFJvd3MoKX1cbiAgICAgICAgICAgICAgICAgICAgb25JbnRlbGxpZ2VudFJlc2l6ZT17aGFuZGxlSW50ZWxsaWdlbnRSZXNpemV9XG4gICAgICAgICAgICAgICAgICAgIG9uRWRpdD17KCkgPT4gb25DYXJkQ2xpY2sgJiYgb25DYXJkQ2xpY2soY2FyZC5pZCl9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9HcmlkTGF5b3V0PlxuICAgICAgICAgIFxuICAgICAgICAgIHsvKiBFbXB0eSBjZWxsIGdyaWQgZm9yIGFkZGluZyBuZXcgY2FyZHMgKi99XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogYHJlcGVhdCgke2dldEdyaWRDb2x1bW5zKCl9LCAxZnIpYCxcbiAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlUm93czogYHJlcGVhdCgke2dldEdyaWRSb3dzKCl9LCAxZnIpYCxcbiAgICAgICAgICAgICAgZ2FwOiBgJHtnZXRHYXAoKX1weGAsXG4gICAgICAgICAgICAgIHpJbmRleDogNVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7ZW1wdHlHcmlkQ2VsbHMubWFwKCh7IHJvdywgY29sIH0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gaG92ZXJlZENlbGw/LnJvdyA9PT0gcm93ICYmIGhvdmVyZWRDZWxsPy5jb2wgPT09IGNvbDtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAga2V5PXtgY2VsbC0ke3Jvd30tJHtjb2x9YH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW46IGNvbCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGdyaWRSb3c6IHJvdyArIDEsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY3Vyc29yLXBvaW50ZXIgcG9pbnRlci1ldmVudHMtYXV0b1wiXG4gICAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHNldEhvdmVyZWRDZWxsKHsgcm93LCBjb2wgfSl9XG4gICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHNldEhvdmVyZWRDZWxsKG51bGwpfVxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQWRkQ2FyZChyb3csIGNvbCl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgey8qIEVtcHR5IGNlbGwgd2l0aCBob3ZlciBlZmZlY3QgKi99XG4gICAgICAgICAgICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZT17eyBcbiAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc0hvdmVyZWQgPyAxIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogaXNIb3ZlcmVkID8gMSA6IDAuOFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIHJvdW5kZWQtbGcgYm9yZGVyLTIgYm9yZGVyLWRhc2hlZCBib3JkZXItaW5kaWdvLTUwMC80MCBiZy1pbmRpZ28tNTAwLzEwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZUhvdmVyPXt7IHNjYWxlOiAxLjEgfX1cbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZVRhcD17eyBzY2FsZTogMC45IH19XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgcC0yIHJvdW5kZWQtZnVsbCAke1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQWRkTW9yZUNhcmRzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYmctaW5kaWdvLTUwMCB0ZXh0LXdoaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdiZy1yZWQtNTAwIHRleHQtd2hpdGUnXG4gICAgICAgICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7Y2FuQWRkTW9yZUNhcmRzKCkgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8UGx1cyBzaXplPXsxNn0gLz5cbiAgICAgICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgPENyb3duIHNpemU9ezE2fSAvPlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvbW90aW9uLmRpdj5cbiAgICAgICAgICAgICAgICAgIDwvbW90aW9uLmRpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCZW50b0dyaWQ7Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJtb3Rpb24iLCJ1c2VTdG9yZSIsIkJlbnRvQ2FyZENvbXBvbmVudCIsIlBsdXMiLCJDcm93biIsIkdyaWRMYXlvdXQiLCJSZXNpemFibGVDYXJkIiwiQmVudG9HcmlkIiwiY2FyZHMiLCJpc1ByZXZpZXciLCJvbkNhcmRDbGljayIsImNsYXNzTmFtZSIsImN1cnJlbnRMYXlvdXQiLCJ1cGRhdGVDYXJkIiwiYWRkQ2FyZCIsInVzZXJQbGFuIiwiZ3JpZERpbWVuc2lvbnMiLCJzZXRHcmlkRGltZW5zaW9ucyIsIndpZHRoIiwiaGVpZ2h0IiwiY2VsbFNpemUiLCJzZXRDZWxsU2l6ZSIsImhvdmVyZWRDZWxsIiwic2V0SG92ZXJlZENlbGwiLCJncmlkUmVmIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJpc0xheW91dENoYW5naW5nIiwic2V0SXNMYXlvdXRDaGFuZ2luZyIsImFkZGluZ0NhcmQiLCJzZXRBZGRpbmdDYXJkIiwiZW1wdHlHcmlkQ2VsbHMiLCJzZXRFbXB0eUdyaWRDZWxscyIsImNhbGN1bGF0ZURpbWVuc2lvbnMiLCJjdXJyZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvbHMiLCJnZXRHcmlkQ29sdW1ucyIsImdhcFNpemUiLCJnZXRHYXAiLCJ0b3RhbEdhcFdpZHRoIiwiYXZhaWxhYmxlV2lkdGgiLCJjYWxjdWxhdGVkQ2VsbFNpemUiLCJNYXRoIiwiZmxvb3IiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldEdyaWRSb3dzIiwiZ2V0Q2FyZFNpemUiLCJjYXJkIiwiY29sU3BhbiIsInJvd1NwYW4iLCJzaXplIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJhZGFwdGVkQ29sU3BhbiIsIm1pbiIsImhhc0NvbGxpc2lvbiIsImNhcmRJZCIsImNvbCIsInJvdyIsImlkIiwiZ3JpZFBvc2l0aW9uIiwiY2FyZENvbFNwYW4iLCJjYXJkUm93U3BhbiIsIm92ZXJsYXAiLCJoYW5kbGVJbnRlbGxpZ2VudFJlc2l6ZSIsIm5ld0NvbHMiLCJuZXdSb3dzIiwiZmluZCIsImMiLCJjdXJyZW50Q29sIiwiY3VycmVudFJvdyIsImdldExheW91dEl0ZW1zIiwiaSIsIngiLCJ5IiwidyIsImgiLCJzdGF0aWMiLCJtYXhXIiwibWF4SCIsImZpbHRlciIsIkJvb2xlYW4iLCJoYW5kbGVMYXlvdXRDaGFuZ2UiLCJsYXlvdXQiLCJ1cGRhdGVzIiwiaXRlbSIsImxlbmd0aCIsInVwZGF0ZSIsInNldFRpbWVvdXQiLCJpc0NlbGxGcmVlIiwiY2FyZFN0YXJ0Q29sIiwiY2FyZEVuZENvbCIsImNhcmRTdGFydFJvdyIsImNhcmRFbmRSb3ciLCJoYW5kbGVBZGRDYXJkIiwiY2FyZFNpemUiLCJuZXdDYXJkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInVybCIsImJhY2tncm91bmRDb2xvciIsInRleHRDb2xvciIsInJlc3VsdCIsInN1Y2Nlc3MiLCJhbGVydCIsImVycm9yIiwiY29uc29sZSIsImNhbkFkZE1vcmVDYXJkcyIsImdyaWRIZWlnaHQiLCJtYXhDb2xzIiwibWF4Um93cyIsImVtcHR5Q2VsbHMiLCJoYXNTcGFjZSIsInIiLCJwdXNoIiwic2FmZUdyaWRXaWR0aCIsInNhZmVDZWxsU2l6ZSIsImRpdiIsInJlZiIsInN0eWxlIiwibWluSGVpZ2h0IiwicG9zaXRpb24iLCJkaXNwbGF5IiwiZ3JpZFRlbXBsYXRlQ29sdW1ucyIsImdyaWRUZW1wbGF0ZVJvd3MiLCJnYXAiLCJncmlkQ29sdW1uIiwiZ3JpZFJvdyIsImlzUHJldmlld01vZGUiLCJyb3dIZWlnaHQiLCJtYXJnaW4iLCJjb250YWluZXJQYWRkaW5nIiwib25MYXlvdXRDaGFuZ2UiLCJpc0RyYWdnYWJsZSIsImlzUmVzaXphYmxlIiwiY29tcGFjdFR5cGUiLCJwcmV2ZW50Q29sbGlzaW9uIiwidXNlQ1NTVHJhbnNmb3JtcyIsImRyYWdnYWJsZUhhbmRsZSIsInJlc2l6ZUhhbmRsZXMiLCJvbkludGVsbGlnZW50UmVzaXplIiwib25FZGl0IiwiekluZGV4IiwiaXNIb3ZlcmVkIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25DbGljayIsImluaXRpYWwiLCJvcGFjaXR5IiwiYW5pbWF0ZSIsInNjYWxlIiwid2hpbGVIb3ZlciIsIndoaWxlVGFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/BentoGrid.tsx\n"));

/***/ })

});